<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | R &amp; R</title>
    <link>/post/</link>
      <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2020 Richard Iannone</copyright><lastBuildDate>Wed, 24 Jun 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/img/R_and_R_share.png</url>
      <title>Posts</title>
      <link>/post/</link>
    </image>
    
    <item>
      <title>pointblank v0.4</title>
      <link>/post/pointblank-0-4/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/post/pointblank-0-4/</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;html&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;/post/css/style.css&#34; /&gt;
&lt;/html&gt;
&lt;html&gt;
&lt;div class=&#34;tab&#34;&gt;
&lt;button class=&#34;tablinks&#34; onclick=&#34;openLang(event, &amp;#39;English&amp;#39;)&#34; id=&#34;defaultOpen&#34;&gt;
English
&lt;/button&gt;
&lt;button class=&#34;tablinks&#34; onclick=&#34;openLang(event, &amp;#39;French&amp;#39;)&#34;&gt;
French
&lt;/button&gt;
&lt;button class=&#34;tablinks&#34; onclick=&#34;openLang(event, &amp;#39;German&amp;#39;)&#34;&gt;
German
&lt;/button&gt;
&lt;/div&gt;
&lt;/html&gt;
&lt;!-- Start English Section --&gt;
&lt;div id=&#34;English&#34; class=&#34;tabcontent&#34;&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/pointblank_v0_4.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;https://rich-iannone.github.io/pointblank/&#34;&gt;&lt;strong&gt;pointblank&lt;/strong&gt;&lt;/a&gt; package is now at version 0.4 and is chock full of goodies. There are new functions that allow us to do really interesting things with data validation. Some of the existing functions gained new superpowers. The docs? Better than ever! They’ve been totally revised and there are plenty of easy-to-use examples too. You can install &lt;strong&gt;pointblank&lt;/strong&gt; 0.4 from CRAN with:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;pointblank&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the last iteration of &lt;strong&gt;pointblank&lt;/strong&gt; the goal was to enable two important, yet quite distinct, data validation workflows using a common set of validation step functions. Let’s have another look at the rationale for those, which were:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;data quality reporting&lt;/li&gt;
&lt;li&gt;pipeline-based data validation&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For the first one, why is it so important? If you are dealing with data, and I’m sure you are, you really need to understand and get on top of data quality. Is the data good? Is it bad? What parts are good or bad? Are the bad parts &lt;em&gt;really&lt;/em&gt; bad? Can we understand what’s making it bad? (I’m just assuming it’s bad.) Lots of questions, and we can get to answering them, so long as we have a process. What I’m hoping is that &lt;strong&gt;pointblank&lt;/strong&gt; is up to the task.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/data_quality_workflow.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The second workflow is also important, but it’s really different than the first. The idea is that you need to check your data before it proceeds further down a pipeline. Perhaps the input data (rigorously checked and cleaned, thanks to data quality reporting) is just fine, but, what about the transformed data in a pipeline? We ought to check that data too.&lt;/p&gt;
&lt;p&gt;Those are the main workflows but there are some new ways of using &lt;strong&gt;pointblank&lt;/strong&gt; now.&lt;/p&gt;
&lt;div id=&#34;expectation-functions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;em&gt;Expectation&lt;/em&gt; Functions&lt;/h2&gt;
&lt;p&gt;There are now 24 &lt;em&gt;expectation&lt;/em&gt; functions (e.g., &lt;code&gt;expect_col_exists()&lt;/code&gt;, &lt;code&gt;expect_rows_distinct()&lt;/code&gt;, &lt;code&gt;expect_col_schema_match()&lt;/code&gt;, etc.) as complements to the 24 validation functions. All of these can be used for &lt;strong&gt;testthat&lt;/strong&gt; tests of tabular data. These new functions have a simplified interface that exposes an easy-to-use failure threshold (defaulting to &lt;code&gt;1&lt;/code&gt;). We’ll go through some examples with the &lt;code&gt;small_table&lt;/code&gt; dataset included in &lt;strong&gt;pointblank&lt;/strong&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;small_table&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; # A tibble: 13 x 8
#&amp;gt;    date_time           date           a b             c      d e     f    
#&amp;gt;    &amp;lt;dttm&amp;gt;              &amp;lt;date&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt;
#&amp;gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&amp;gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&amp;gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&amp;gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&amp;gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&amp;gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&amp;gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&amp;gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&amp;gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&amp;gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&amp;gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&amp;gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&amp;gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high &lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# With the `expect_*()` form, we would
# typically perform one validation at a time
# (the same way that testthat tests operate)
expect_col_vals_between(
  small_table, vars(c), 1, 9,
  na_pass = TRUE
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This returns absolutely nothing, which means the test worked! In the case that it doesn’t work, we get an informative message:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;expect_col_vals_between(
  small_table, vars(c), 23, 34,
  na_pass = TRUE
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Error: Exceedance of failed test units where values in `c` should have been between `23` and `34`.
The `expect_col_vals_between()` validation failed beyond the absolute threshold level (1).
* failure level (11) &amp;gt;= failure threshold (1) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By the way, these messages are consistent with the error and warning messages that are shown when using validation functions directly on data (e.g., &lt;code&gt;small_table %&amp;gt;% col_vals_between(...)&lt;/code&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;test-functions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;em&gt;Test&lt;/em&gt; Functions&lt;/h2&gt;
&lt;p&gt;On top of the &lt;code&gt;expect_*()&lt;/code&gt; set of functions, there are now 24 &lt;em&gt;test&lt;/em&gt; functions (e.g., &lt;code&gt;test_col_exists()&lt;/code&gt;, &lt;code&gt;test_rows_distinct()&lt;/code&gt;, &lt;code&gt;test_col_schema_match()&lt;/code&gt;, etc.) to further complement the 24 validation functions. These functions return a logical value: &lt;code&gt;TRUE&lt;/code&gt; if the failure threshold (having a default of 1) &lt;em&gt;is not&lt;/em&gt; exceeded, &lt;code&gt;FALSE&lt;/code&gt; otherwise. These &lt;code&gt;test_*()&lt;/code&gt; functions use the same simplified interface of the &lt;code&gt;expect_*()&lt;/code&gt; functions.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# With the `test_*()` form, we should get a
# single logical value returned to us
test_col_vals_between(
  small_table, vars(c), 1, 9,
  na_pass = TRUE
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;col_vals_expr-expect_col_vals_expr-and-test_col_vals_expr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;col_vals_expr()&lt;/code&gt;, &lt;code&gt;expect_col_vals_expr()&lt;/code&gt;, and &lt;code&gt;test_col_vals_expr()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;For those times when you just want a DIY expression for your validation, the &lt;code&gt;col_vals_expr()&lt;/code&gt; function (and the &lt;em&gt;expectation&lt;/em&gt; and &lt;em&gt;test&lt;/em&gt; variants) could be what you need. The &lt;strong&gt;dplyr&lt;/strong&gt; &lt;code&gt;expr()&lt;/code&gt;, &lt;code&gt;case_when()&lt;/code&gt;, and &lt;code&gt;between()&lt;/code&gt; functions are now re-exported in &lt;strong&gt;pointblank&lt;/strong&gt; for easier accessibility here since they work exceedingly well with the new functions. Here’s an example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Let&amp;#39;s use a tiny table for testing here
tbl &amp;lt;-
  dplyr::tibble(
    a = c(1, 2, 1, 7, 8, 6),
    b = c(0, 0, 0, 1, 1, 1),
    c = c(0.5, 0.3, 0.8, 1.4, 1.9, 1.2),
  )
  
tbl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; # A tibble: 6 x 3
#&amp;gt;       a     b     c
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
#&amp;gt; 1     1     0   0.5
#&amp;gt; 2     2     0   0.3
#&amp;gt; 3     1     0   0.8
#&amp;gt; 4     7     1   1.4
#&amp;gt; 5     8     1   1.9
#&amp;gt; 6     6     1   1.2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Test that values in column `a`
# are integer-like by using the R modulo
# operator and expecting `0`
test_col_vals_expr(tbl, ~ a %% 1 == 0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# We can do more complex things by
# taking advantage of the `case_when()`
# and `between()` functions (available
# for use in the pointblank package) 
tbl %&amp;gt;%
  test_col_vals_expr(~ case_when(
    b == 0 ~ a %&amp;gt;% between(0, 5) &amp;amp; c &amp;lt; 1,
    b == 1 ~ a &amp;gt; 5 &amp;amp; c &amp;gt;= 1
  ))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Should the evaluation of the expression not work out (for example, if the non-existent &lt;code&gt;d&lt;/code&gt; column were to be used in the above example) you’ll get an &lt;code&gt;NA&lt;/code&gt; value returned. If using an agent, the report will show that the evaluation was unsuccessful (look for the explosion in the &lt;code&gt;EVAL&lt;/code&gt; column).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;new-r-markdown-features&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;New &lt;strong&gt;R Markdown&lt;/strong&gt; Features&lt;/h2&gt;
&lt;p&gt;Almost forgot about this one! A new &lt;strong&gt;R Markdown&lt;/strong&gt; validation feature allows for validation testing within specialized validation code chunks where the &lt;code&gt;validate = TRUE&lt;/code&gt; option is set. Using pointblank validation functions on data in these marked code chunks will flag overall failure if the stop threshold is exceeded anywhere. All errors are reported in the validation code chunk after rendering the document to HTML, where green or red status buttons indicate whether all validations succeeded or failures occurred. But, better to show than to explain, here’s an animation:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/pointblank_rmarkdown.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;There’s a very useful R Markdown template for this new &lt;strong&gt;R Markdown&lt;/strong&gt; validation feature: &lt;code&gt;Pointblank Validation&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Using &lt;strong&gt;pointblank&lt;/strong&gt; in an &lt;strong&gt;R Markdown&lt;/strong&gt; workflow is enabled by default once the pointblank library is loaded. While the framework for such testing is set up by default, the new &lt;code&gt;validate_rmd()&lt;/code&gt; function offers an opportunity to set UI and logging options.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-agent-report&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The &lt;strong&gt;agent&lt;/strong&gt; Report&lt;/h2&gt;
&lt;p&gt;The appearance of the agent report has improved (a lot!) and it’s gained some new features:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;data extracts for failing rows (on row-based validation steps) can be downloaded as CSVs via the new buttons that appear in the &lt;code&gt;EXT&lt;/code&gt; column&lt;/li&gt;
&lt;li&gt;there are useful tooltips on most fields of the table (e.g., hovering over items in &lt;code&gt;STEP&lt;/code&gt; will show the ‘brief’, &lt;code&gt;TBL&lt;/code&gt; icons will describe whether any preconditions were applied to the table prior to interrogation, etc.), and&lt;/li&gt;
&lt;li&gt;there are printing improvements in the &lt;code&gt;COLUMNS&lt;/code&gt; and &lt;code&gt;VALUES&lt;/code&gt; columns (e.g., table columns are distinguished from literal values).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here’s a diagram that better explains the whole thing:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/agent_report.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This bit of reporting is really important so expect even more improvements in an upcoming version.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;scanning-your-data-with-scan_data-improvements&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Scanning Your Data with &lt;code&gt;scan_data()&lt;/code&gt;: Improvements!&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;scan_data()&lt;/code&gt; function let’s you ‘Thoroughly scan the table data so as to understand it better’ (that’s from the help page, at &lt;code&gt;?scan_data&lt;/code&gt;). In case you haven’t seen it, this function generates an HTML report that explains the input table data. It’s a great thing to use before calling up an &lt;strong&gt;agent&lt;/strong&gt; to validate the data. With this function, we can now quickly get to understanding the data with some level of precision. The reporting output contains several sections to make everything more digestible, and these are:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Overview: Table dimensions, duplicate row count, column types, and reproducibility information&lt;/li&gt;
&lt;li&gt;Variables: A summary for each table variable and further statistics and summaries depending on the variable type&lt;/li&gt;
&lt;li&gt;Interactions: A matrix plot that shows interactions between variables&lt;/li&gt;
&lt;li&gt;Correlations: A set of correlation matrix plots for numerical variables&lt;/li&gt;
&lt;li&gt;Missing Values: A summary figure that shows the degree of missingness across variables, and&lt;/li&gt;
&lt;li&gt;Sample: A table that provides the head and tail rows of the dataset&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/table_scan.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It’s pretty cool! Try it out with your favorite dataset. I created a few examples, in various languages even, in &lt;strong&gt;RPubs&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_english&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=English&amp;amp;color=blue&#34; alt=&#34;Table Scan in English&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_french&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=French&amp;amp;color=blue&#34; alt=&#34;Table Scan in French&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_german&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=German&amp;amp;color=blue&#34; alt=&#34;Table Scan in German&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_italian&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=Italian&amp;amp;color=blue&#34; alt=&#34;Table Scan in Italian&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_spanish&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=Spanish&amp;amp;color=blue&#34; alt=&#34;Table Scan in Spanish&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;All of those Table Scans are of the &lt;code&gt;dplyr::storms&lt;/code&gt; dataset. But whaddabout database tables? That’s the improvement this time round! You can now use &lt;code&gt;scan_data()&lt;/code&gt; to scan some DB tables. Here are two brand-new examples using the &lt;code&gt;full_region&lt;/code&gt; table of the &lt;strong&gt;Rfam&lt;/strong&gt; database (hosted publicly at “mysql-rfam-public.ebi.ac.uk”) and the &lt;code&gt;assembly&lt;/code&gt; table of the &lt;strong&gt;Ensembl&lt;/strong&gt; database (hosted publicly at “ensembldb.ensembl.org”).&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://rpubs.com/rich_i/rfam_full_region&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=Rfam:%20full_region&amp;amp;color=green&#34; alt=&#34;Rfam: full_region&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/ensembl_assembly&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=Ensembl:%20assembly&amp;amp;color=green&#34; alt=&#34;Ensembl: assembly&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;nicer-lookin-email&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Nicer Lookin’ Email&lt;/h2&gt;
&lt;p&gt;You can send HTML email with the agent report inside (thanks to some help by the &lt;strong&gt;blastula&lt;/strong&gt; package). There’s seemingly no limit to the customizability of the message body, since the &lt;code&gt;email_blast()&lt;/code&gt; function has full access to the agent intel (have a look at the help article at &lt;code&gt;?email_blast&lt;/code&gt; for all the details on this). However, sometimes you want a reasonably-nice default email that won’t take much work to develop. In this release, the default look of the email is much easier on the eyes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/pointblank_email.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It uses a small version of the agent report (575px wide) that still has those useful tooltips that provide &lt;em&gt;briefs&lt;/em&gt; (an unfortunate name for the short descriptions of each validation step). Sure, you could customize the email yourself with the &lt;code&gt;msg_header&lt;/code&gt;, &lt;code&gt;msg_body&lt;/code&gt;, and &lt;code&gt;msg_footer&lt;/code&gt; args but, now, you might not have a compulsion to do so.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;wrapping-up&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;I hope this gives some insight into what &lt;a href=&#34;https://rich-iannone.github.io/pointblank/&#34;&gt;&lt;strong&gt;pointblank&lt;/strong&gt;&lt;/a&gt; is all about and where its development is headed. Aside from these sizable improvements and new features, there were also plenty of bugfixes and smaller quality-of-life changes that made it into this release. As ever, I hope you get a chance to try it out on your own data.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- Start French Section --&gt;
&lt;div id=&#34;French&#34; class=&#34;tabcontent&#34;&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/pointblank_v0_4.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Le package &lt;a href=&#34;https://rich-iannone.github.io/pointblank/&#34;&gt;&lt;strong&gt;pointblank&lt;/strong&gt;&lt;/a&gt; est maintenant à la version 0.4 et regorge de bonbons. Il y a de nouvelles fonctions qui nous permettent de faire des choses vraiment intéressantes avec la validation des données. Certaines des fonctions existantes ont acquis de nouvelles superpuissances. La documentation? Mieux que jamais! Ils ont été entièrement révisés et il existe également de nombreux exemples faciles à utiliser. Vous pouvez installer &lt;strong&gt;pointblank&lt;/strong&gt; 0.4 de CRAN avec:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;pointblank&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Avec la dernière version de ** pointblank **, l’objectif était d’activer deux workflows de validation de données importants, mais assez distincts, à l’aide d’un ensemble commun de fonctions d’étape de validation. Jetons un autre regard sur la justification de ceux-ci, qui étaient:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;rapports sur la qualité des données&lt;/li&gt;
&lt;li&gt;validation des données basée sur le pipeline&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Pourquoi le premier point est-il si important? Si vous traitez avec des données, et je suis sûr que vous l’êtes, vous devez vraiment comprendre et maîtriser la qualité des données. Les données sont-elles bonnes? Est-il mauvais? Quelles parties sont bonnes ou mauvaises? Les mauvaises parties sont-elles vraiment mauvaises? Pouvons-nous comprendre ce qui le rend mauvais? (Je suppose simplement que c’est mauvais.) Beaucoup de questions, et nous pouvons y répondre, tant que nous avons un processus. Ce que j’espère, c’est que &lt;strong&gt;pointblank&lt;/strong&gt; est assez bon pour tout cela.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/data_quality_workflow.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Le deuxième flux de travail est également important, mais il est vraiment différent du premier. Vous devez vérifier vos données avant de poursuivre leur progression dans un pipeline. Peut-être que les données d’entrée (rigoureusement vérifiées et nettoyées, grâce aux rapports sur la qualité des données) sont très bien, mais qu’en est-il des données transformées dans un pipeline? Allons! Il faut le vérifier et vous le savez! Vous pourriez avoir de graves problèmes si vous ignorez tout cela. Alors faites-le! Simplement fais-le!&lt;/p&gt;
&lt;p&gt;Quoi qu’il en soit, ce sont les principaux workflows. Il y a de nouvelles choses qui permettent de nouvelles façons d’utiliser &lt;strong&gt;pointblank&lt;/strong&gt;. C’est assez excitant!&lt;/p&gt;
&lt;div id=&#34;expectation-fonctions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;em&gt;Expectation&lt;/em&gt; fonctions&lt;/h2&gt;
&lt;p&gt;Il existe désormais 24 fonctions &lt;em&gt;expectation&lt;/em&gt; (par exemple, &lt;code&gt;expect_col_exists()&lt;/code&gt;, &lt;code&gt;expect_rows_distinct()&lt;/code&gt;, &lt;code&gt;expect_col_schema_match()&lt;/code&gt;, etc.) en complément des 24 fonctions de validation. Tous ces éléments peuvent être utilisés pour &lt;strong&gt;testthat&lt;/strong&gt; tests de données tabulaires avec une interface simplifiée qui expose un seuil de défaillance facile à utiliser (par défaut à &lt;code&gt;1&lt;/code&gt;). Explorons cela à travers des exemples. Nous utiliserons l’ensemble de données &lt;code&gt;small_table&lt;/code&gt; inclus dans &lt;strong&gt;pointblank&lt;/strong&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;small_table&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; # A tibble: 13 x 8
#&amp;gt;    date_time           date           a b             c      d e     f    
#&amp;gt;    &amp;lt;dttm&amp;gt;              &amp;lt;date&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt;
#&amp;gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&amp;gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&amp;gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&amp;gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&amp;gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&amp;gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&amp;gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&amp;gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&amp;gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&amp;gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&amp;gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&amp;gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&amp;gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high &lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Avec le formulaire `expect_*()`, nous
# effectue généralement une validation à la fois
# (de la même manière que les tests fonctionnent)
expect_col_vals_between(
  small_table, vars(c), 1, 9,
  na_pass = TRUE
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cela ne renvoie rien. Rien du tout. C’est bien! Cela signifie que le test a fonctionné! Dans le cas où cela ne fonctionne pas, nous obtenons un message informatif:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;expect_col_vals_between(
  small_table, vars(c), 23, 34,
  na_pass = TRUE
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Error: Exceedance of failed test units where values in `c` should have been between `23` and `34`.
The `expect_col_vals_between()` validation failed beyond the absolute threshold level (1).
* failure level (11) &amp;gt;= failure threshold (1) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ces messages sont cohérents avec les messages d’erreur et d’avertissement qui s’affichent lors de l’utilisation de fonctions de validation directement sur les données (par exemple, &lt;code&gt;small_table %&amp;gt;% col_vals_between (...)&lt;/code&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;test-fonctions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;em&gt;Test&lt;/em&gt; fonctions&lt;/h2&gt;
&lt;p&gt;En plus de l’ensemble de fonctions &lt;code&gt;expect_*()&lt;/code&gt;, il existe désormais 24 &lt;em&gt;fonctions test&lt;/em&gt; (par exemple, &lt;code&gt;test_col_exists()&lt;/code&gt;, &lt;code&gt;test_rows_distinct()&lt;/code&gt;, &lt;code&gt;test_col_schema_match()&lt;/code&gt;, etc.) pour compléter 24 fonctions de validation. Ces fonctions renvoient une valeur logique: &lt;code&gt;TRUE&lt;/code&gt; si le seuil de défaillance (ayant une valeur par défaut de &lt;code&gt;1&lt;/code&gt;) &lt;em&gt;n’est pas&lt;/em&gt; dépassé, &lt;code&gt;FALSE&lt;/code&gt; sinon. Ces fonctions &lt;code&gt;test_*()&lt;/code&gt; utilisent la même interface simplifiée que les fonctions &lt;code&gt;expect_*()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Avec le formulaire `test_*()`, nous
# devrions obtenir un valeur TRUE ou FALSE
# unique qui nous est retournée
test_col_vals_between(
  small_table, vars(c), 1, 9,
  na_pass = TRUE
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;col_vals_expr-expect_col_vals_expr-et-test_col_vals_expr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;col_vals_expr()&lt;/code&gt;, &lt;code&gt;expect_col_vals_expr()&lt;/code&gt; et &lt;code&gt;test_col_vals_expr()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Si vous voulez juste une expression simple pour votre validation, la fonction &lt;code&gt;col_vals_expr()&lt;/code&gt; (et les variantes &lt;em&gt;expectation&lt;/em&gt; et &lt;em&gt;test&lt;/em&gt;) pourrait être ce dont vous avez besoin. Les fonctions &lt;strong&gt;dplyr&lt;/strong&gt; &lt;code&gt;expr()&lt;/code&gt;, &lt;code&gt;case_when()&lt;/code&gt; et &lt;code&gt;between()&lt;/code&gt; sont maintenant réexportées dans &lt;strong&gt;pointblank&lt;/strong&gt; pour une accessibilité plus facile ici. Ils fonctionnent à merveille avec les nouvelles fonctions. Voici un exemple:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Utilisons une p&amp;#39;tit table pour tester
tbl &amp;lt;-
  dplyr::tibble(
    a = c(1, 2, 1, 7, 8, 6),
    b = c(0, 0, 0, 1, 1, 1),
    c = c(0.5, 0.3, 0.8, 1.4, 1.9, 1.2),
  )
  
tbl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; # A tibble: 6 x 3
#&amp;gt;       a     b     c
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
#&amp;gt; 1     1     0   0.5
#&amp;gt; 2     2     0   0.3
#&amp;gt; 3     1     0   0.8
#&amp;gt; 4     7     1   1.4
#&amp;gt; 5     8     1   1.9
#&amp;gt; 6     6     1   1.2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Testez les valeurs de la colonne `a`
# sont de type entier en utilisant le
# module R opérateur et attend `0`
test_col_vals_expr(tbl, ~ a %% 1 == 0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# Nous pouvons faire des choses plus
# complexes en profitant du `case_when()`
# et `between()` fonctions (disponibles
# à utiliser dans le package pointblank)
tbl %&amp;gt;%
  test_col_vals_expr(~ case_when(
    b == 0 ~ a %&amp;gt;% between(0, 5) &amp;amp; c &amp;lt; 1,
    b == 1 ~ a &amp;gt; 5 &amp;amp; c &amp;gt;= 1
  ))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Si l’évaluation de l’expression ne fonctionne pas (par exemple, la colonne &lt;code&gt;d&lt;/code&gt; inexistante a été utilisée ci-dessus), vous obtiendrez une valeur &lt;code&gt;NA&lt;/code&gt;. Si vous utilisez un agent, le rapport montrera que l’évaluation a échoué (recherchez l’explosion dans la colonne &lt;code&gt;EVAL&lt;/code&gt;). C’est la bombe!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;nouvelles-fonctionnalités-r-markdown&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Nouvelles fonctionnalités &lt;strong&gt;R Markdown&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Une nouvelle fonctionnalité de validation R Markdown permet d’effectuer des tests de validation dans des blocs de code de validation spécialisés où l’option &lt;code&gt;validate = TRUE&lt;/code&gt; est définie. Voici une animation qui montre comment cela fonctionne:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/pointblank_rmarkdown.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Il existe un nouveau template R Markdown pour cela, appelé «Pointblank Validation».&lt;/p&gt;
&lt;p&gt;L’utilisation de &lt;strong&gt;pointblank&lt;/strong&gt; dans un workflow &lt;strong&gt;R Markdown&lt;/strong&gt; est activée par défaut une fois &lt;strong&gt;pointblank&lt;/strong&gt; chargée. La nouvelle fonction &lt;code&gt;validate_rmd()&lt;/code&gt; offre la possibilité de définir des options de journalisation.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;le-rapport-dagent&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Le rapport d’&lt;strong&gt;agent&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;L’apparence du rapport d’agent est désormais bien meilleure. Il a gagné de nouvelles fonctionnalités:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;les extraits de données pour les lignes défaillantes (lors des étapes de validation basées sur les lignes) peuvent être téléchargés au format CSV via les nouveaux boutons qui apparaissent dans la colonne &lt;code&gt;EXT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;il existe des info-bulles utiles sur la plupart des champs du tableau (par exemple, survoler les éléments dans &lt;code&gt;STEP&lt;/code&gt; affichera le résumé, les icônes &lt;code&gt;TBL&lt;/code&gt; décriront si des conditions préalables ont été appliquées au tableau avant l’interrogation, etc.), et&lt;/li&gt;
&lt;li&gt;il y a des améliorations d’impression dans les colonnes &lt;code&gt;COLUMNS&lt;/code&gt; et &lt;code&gt;VALUES&lt;/code&gt; (par exemple, les colonnes du tableau sont distinguées des valeurs littérales).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Voici un diagramme utile:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/agent_report.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Ce rapport est super important. Attendez-vous à d’autres améliorations dans un avenir proche.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;améliorations-avec-scan_data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Améliorations avec &lt;code&gt;scan_data()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Au cas où vous ne l’auriez pas vu, cette fonction génère un rapport HTML qui parcourt les données de la table d’entrée. C’est une bonne chose à utiliser avant d’appeler un &lt;strong&gt;agent&lt;/strong&gt; pour valider les données. Avec cette fonction, nous pouvons maintenant rapidement comprendre les données avec un certain niveau de précision. La sortie du rapport contient plusieurs sections pour rendre tout plus digestible, et ce sont:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Aperçu: dimensions de la table, nombre de lignes en double, types de colonnes et informations de reproductibilité&lt;/li&gt;
&lt;li&gt;Variables: un résumé pour chaque variable du tableau et d’autres statistiques et résumés selon le type de variable&lt;/li&gt;
&lt;li&gt;Interactions: un graphique matriciel qui montre les interactions entre les variables&lt;/li&gt;
&lt;li&gt;Corrélations: un ensemble de graphiques matriciels de corrélation pour les variables numériques&lt;/li&gt;
&lt;li&gt;Valeurs manquantes: une figure récapitulative qui montre le degré de disparité entre les variables, et&lt;/li&gt;
&lt;li&gt;Exemple: un tableau qui fournit les lignes de tête et de queue de l’ensemble de données&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/table_scan.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;C’est bon! Essayez-le avec votre jeu de données préféré. J’ai créé quelques exemples, dans différentes langues même, dans &lt;strong&gt;RPubs&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_english&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=English&amp;amp;color=blue&#34; alt=&#34;Table Scan in English&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_french&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=French&amp;amp;color=blue&#34; alt=&#34;Table Scan in French&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_german&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=German&amp;amp;color=blue&#34; alt=&#34;Table Scan in German&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_italian&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=Italian&amp;amp;color=blue&#34; alt=&#34;Table Scan in Italian&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_spanish&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=Spanish&amp;amp;color=blue&#34; alt=&#34;Table Scan in Spanish&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tous ces éléments font partie de l’ensemble de données &lt;code&gt;dplyr::storms&lt;/code&gt;. Mais à propos des tables de base de données? C’est l’amélioration cette fois-ci! Vous pouvez maintenant utiliser &lt;code&gt;scan_data()&lt;/code&gt; pour analyser certaines tables de base de données. Voici deux nouveaux exemples utilisant la table &lt;code&gt;full_region&lt;/code&gt; de la base de données &lt;strong&gt;Rfam&lt;/strong&gt; (hébergée publiquement sur “mysql-rfam-public.ebi.ac.uk”) et la table &lt;code&gt;assembly&lt;/code&gt; de &lt;strong&gt;Ensembl&lt;/strong&gt; base de données (hébergée publiquement sur “ensembldb.ensembl.org”).&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://rpubs.com/rich_i/rfam_full_region&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=Rfam:%20full_region&amp;amp;color=green&#34; alt=&#34;Rfam: full_region&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/ensembl_assembly&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=Ensembl:%20assembly&amp;amp;color=green&#34; alt=&#34;Ensembl: assembly&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;courriel-jaime-le-way-quà-hang&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Courriel: J’aime le way qu’à hang&lt;/h2&gt;
&lt;p&gt;Vous pouvez envoyer un e-mail HTML avec le rapport de l’agent à l’intérieur (grâce à l’aide du package &lt;strong&gt;blastula&lt;/strong&gt;). Il n’y a apparemment aucune limite à la personnalisation du corps du message, car la fonction &lt;code&gt;email_blast()&lt;/code&gt; a un accès complet aux informations de l’agent (consultez l’article d’aide à &lt;code&gt;?email_blast&lt;/code&gt; pour tous les détails à ce sujet). Cependant, parfois, vous voulez un e-mail par défaut assez agréable qui ne prendra pas beaucoup de travail à envoyer. Dans cette version, l’apparence par défaut de l’e-mail est beaucoup plus facile pour les yeux.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/pointblank_email.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Il utilise une petite version du rapport d’agent (575 px de large) qui a toujours des info-bulles qui fournissent des &lt;em&gt;briefs&lt;/em&gt; (un nom malheureux en anglais pour les courtes descriptions de chaque étape de validation). Bien sûr, vous pouvez personnaliser l’e-mail avec les arguments &lt;code&gt;msg_header&lt;/code&gt;, &lt;code&gt;msg_body&lt;/code&gt; et &lt;code&gt;msg_footer&lt;/code&gt; mais, maintenant, vous n’avez peut-être pas la contrainte de le faire.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;J’espère que cela vous donnera un aperçu de ce qu’est &lt;a href=&#34;https://rich-iannone.github.io/pointblank/&#34;&gt;&lt;strong&gt;pointblank&lt;/strong&gt;&lt;/a&gt; et de son évolution. Mis à part ces améliorations considérables et ces nouvelles fonctionnalités, de nombreuses corrections de bugs et de petits changements de qualité de vie ont également été intégrés à cette version. Comme toujours, j’espère que vous aurez l’occasion de l’essayer sur vos propres données.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;!-- Start German Section --&gt;
&lt;div id=&#34;German&#34; class=&#34;tabcontent&#34;&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/pointblank_v0_4.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Das &lt;a href=&#34;https://rich-iannone.github.io/pointblank/&#34;&gt;&lt;strong&gt;pointblank&lt;/strong&gt;-Paket&lt;/a&gt; ist jetzt in Version 0.4 und voller Goodies. Es gibt neue Funktionen, mit denen wir wirklich interessante Dinge mit der Datenvalidierung tun können. Einige der bestehenden Funktionen erhielten neue Superkräfte. Die Dokumentation? Besser denn je! Sie wurden komplett überarbeitet und es gibt auch viele benutzerfreundliche Beispiele. Sie können &lt;strong&gt;pointblank&lt;/strong&gt; 0.4 von CRAN installieren mit:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;pointblank&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mit der letzten Version von &lt;strong&gt;pointblank&lt;/strong&gt; bestand das Ziel darin, zwei wichtige, jedoch recht unterschiedliche Datenvalidierungs-Workflows mithilfe eines gemeinsamen Satzes von Validierungsschrittfunktionen zu ermöglichen. Lassen Sie uns noch einen Blick auf die Gründe für diejenigen werfen, die waren:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Berichterstattung zur Datenqualität&lt;/li&gt;
&lt;li&gt;Pipeline-basierte Datenvalidierung2. pipeline-based data validation&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Warum ist es für den ersten so wichtig? Wenn Sie mit Daten zu tun haben und ich bin sicher, dass Sie es sind, müssen Sie die Datenqualität wirklich verstehen und auf den neuesten Stand bringen. Sind die Daten gut? Ist es schlimm? Welche Teile sind gut oder schlecht? Sind die schlechten Teile &lt;em&gt;wirklich&lt;/em&gt; schlecht? Können wir verstehen, was es schlecht macht? (Ich gehe nur davon aus, dass es schlecht ist.) Viele Fragen, und wir können sie beantworten, solange wir einen Prozess haben. Was ich hoffe ist, dass &lt;strong&gt;pointblank&lt;/strong&gt; der Aufgabe gewachsen ist.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/data_quality_workflow.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Der zweite Workflow ist ebenfalls wichtig, unterscheidet sich jedoch erheblich vom ersten. Die Idee ist, dass Sie Ihre Daten überprüfen müssen, bevor sie weiter unten in einer Pipeline fortgesetzt werden. Vielleicht sind die Eingabedaten (dank Datenqualitätsberichterstattung streng geprüft und bereinigt) in Ordnung, aber was ist mit den transformierten Daten in einer Pipeline? Wir sollten auch diese Daten überprüfen.&lt;/p&gt;
&lt;p&gt;Dies sind die Hauptworkflows, aber es gibt jetzt einige neue Möglichkeiten, &lt;strong&gt;pointblank&lt;/strong&gt; zu verwenden.&lt;/p&gt;
&lt;div id=&#34;expectation-funktionen&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;em&gt;Expectation&lt;/em&gt; Funktionen&lt;/h2&gt;
&lt;p&gt;Es gibt jetzt 24 &lt;em&gt;Expectation&lt;/em&gt;-Funktionen (z. B. &lt;code&gt;expect_col_exists()&lt;/code&gt;, &lt;code&gt;expect_rows_distinct()&lt;/code&gt;, &lt;code&gt;expect_col_schema_match()&lt;/code&gt; usw.) als Ergänzungen der 24 Validierungsfunktionen. All dies kann für &lt;strong&gt;testthat&lt;/strong&gt; Testen von Tabellendaten mit einer vereinfachten Oberfläche verwendet werden, die einen benutzerfreundlichen Fehlerschwellenwert (standardmäßig &lt;code&gt;1&lt;/code&gt;) anzeigt. Wir werden einige Beispiele mit dem in &lt;strong&gt;pointblank&lt;/strong&gt; enthaltenen &lt;code&gt;small_table&lt;/code&gt;-Dataset durchgehen.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;small_table&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; # A tibble: 13 x 8
#&amp;gt;    date_time           date           a b             c      d e     f    
#&amp;gt;    &amp;lt;dttm&amp;gt;              &amp;lt;date&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt;
#&amp;gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&amp;gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&amp;gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&amp;gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&amp;gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&amp;gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&amp;gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&amp;gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&amp;gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&amp;gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&amp;gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&amp;gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&amp;gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high &lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Mit dem Formular `expect_*()` würden
# wir Führen Sie normalerweise jeweils
# eine Validierung durch (genauso wie
# testthat Tests funktionieren)
expect_col_vals_between(
  small_table, vars(c), 1, 9,
  na_pass = TRUE
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dies gibt absolut nichts zurück: eine Leere. Dies bedeutet, dass der Test funktioniert hat. Falls es nicht funktioniert, erhalten wir eine informative Nachricht:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;expect_col_vals_between(
  small_table, vars(c), 23, 34,
  na_pass = TRUE
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Error: Exceedance of failed test units where values in `c` should have been between `23` and `34`.
The `expect_col_vals_between()` validation failed beyond the absolute threshold level (1).
* failure level (11) &amp;gt;= failure threshold (1) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Übrigens stimmen diese Meldungen mit den Fehler- und Warnmeldungen überein, die angezeigt werden, wenn Validierungsfunktionen direkt für Daten verwendet werden (z. B. &lt;code&gt;small_table %&amp;gt;% col_vals_between(...)&lt;/code&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;test-funktionen&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;em&gt;Test&lt;/em&gt; Funktionen&lt;/h2&gt;
&lt;p&gt;Abgesehen von dem Funktionssatz &lt;code&gt;expect_*()&lt;/code&gt; gibt es jetzt 24 &lt;em&gt;test&lt;/em&gt;-Funktionen (z. B. &lt;code&gt;test_col_exists()&lt;/code&gt;, &lt;code&gt;test_rows_distinct()&lt;/code&gt;, &lt;code&gt;test_col_schema_match()&lt;/code&gt; usw.), um die 24 weiter zu ergänzen Validierungsfunktionen. Diese Funktionen geben einen logischen Wert zurück: &lt;code&gt;TRUE&lt;/code&gt;, wenn der Fehlerschwellenwert (mit einem Standardwert von 1) &lt;em&gt;nicht&lt;/em&gt; überschritten wird, andernfalls &lt;code&gt;FALSE&lt;/code&gt;. Diese &lt;code&gt;test_*()&lt;/code&gt; Funktionen verwenden dieselbe vereinfachte Schnittstelle wie die &lt;code&gt;expect_*()&lt;/code&gt; Funktionen.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Mit dem Formular `test_*()` sollten wir einen
# einzelnen TRUE- oder FALSE-Wert erhalten, der
# an uns zurückgegeben wird
test_col_vals_between(
  small_table, vars(c), 1, 9,
  na_pass = TRUE
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;col_vals_expr-expect_col_vals_expr-und-test_col_vals_expr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;col_vals_expr()&lt;/code&gt;, &lt;code&gt;expect_col_vals_expr()&lt;/code&gt;, und &lt;code&gt;test_col_vals_expr()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Wenn Sie für Ihre Validierung einen einfachen Ausdruck benötigen, könnte die Funktion &lt;code&gt;col_vals_expr()&lt;/code&gt; (und die Varianten &lt;em&gt;expectation&lt;/em&gt; und &lt;em&gt;test&lt;/em&gt;) genau das sein, was Sie benötigen. Die Funktionen &lt;strong&gt;dplyr&lt;/strong&gt; &lt;code&gt;expr()&lt;/code&gt;, &lt;code&gt;case_when()&lt;/code&gt; und &lt;code&gt;between()&lt;/code&gt; werden jetzt in &lt;strong&gt;pointblank&lt;/strong&gt; erneut exportiert, um den Zugriff hier zu erleichtern, da sie mit den neuen Funktionen außerordentlich gut funktionieren. Hier ist ein Beispiel:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Lassen Sie uns hier eine winzige Tabelle
# zum Testen verwenden
tbl &amp;lt;-
  dplyr::tibble(
    a = c(1, 2, 1, 7, 8, 6),
    b = c(0, 0, 0, 1, 1, 1),
    c = c(0.5, 0.3, 0.8, 1.4, 1.9, 1.2),
  )
  
tbl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; # A tibble: 6 x 3
#&amp;gt;       a     b     c
#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
#&amp;gt; 1     1     0   0.5
#&amp;gt; 2     2     0   0.3
#&amp;gt; 3     1     0   0.8
#&amp;gt; 4     7     1   1.4
#&amp;gt; 5     8     1   1.9
#&amp;gt; 6     6     1   1.2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Testen Sie, ob die Werte in Spalte `a`
# ganzzahlig sind, indem Sie den 
# R-Modulo-Operator verwenden und `0` erwarten
test_col_vals_expr(tbl, ~ a %% 1 == 0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# Wir können komplexere Dinge tun, indem
# wir die Funktionen `case_when()` und
# `between()` nutzen (verfügbar für die
# Verwendung im pointblank-Paket).
tbl %&amp;gt;%
  test_col_vals_expr(~ case_when(
    b == 0 ~ a %&amp;gt;% between(0, 5) &amp;amp; c &amp;lt; 1,
    b == 1 ~ a &amp;gt; 5 &amp;amp; c &amp;gt;= 1
  ))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sollte die Auswertung des Ausdrucks nicht funktionieren (z. B. wurde oben die nicht vorhandene Spalte &lt;code&gt;d&lt;/code&gt; verwendet), wird ein &lt;code&gt;NA&lt;/code&gt;-Wert zurückgegeben. Wenn Sie einen Agenten verwenden, zeigt der Bericht, dass die Auswertung nicht erfolgreich war (suchen Sie nach der Explosion in der Spalte &lt;code&gt;EVAL&lt;/code&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;new-r-markdown-features-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;New &lt;strong&gt;R Markdown&lt;/strong&gt; features&lt;/h2&gt;
&lt;p&gt;Eine neue R Markdown-Validierungsfunktion ermöglicht Validierungstests in speziellen Validierungscode-Blöcken, in denen die Option &lt;code&gt;validate = TRUE&lt;/code&gt; festgelegt ist. Die Verwendung von Pointblank-Validierungsfunktionen für Daten in diesen Codeblöcken zeigt einen Gesamtfehler an, wenn der Stoppschwellenwert irgendwo überschritten wird. Alle Fehler werden im Validierungscode-Block gemeldet, nachdem das Dokument in HTML gerendert wurde. Hier ist eine Animation:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/pointblank_rmarkdown.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Hierfür gibt es eine neue R-Markdown-template namens “Pointblank Validation”.&lt;/p&gt;
&lt;p&gt;Using &lt;strong&gt;pointblank&lt;/strong&gt; in an &lt;strong&gt;R Markdown&lt;/strong&gt; workflow is enabled by default once the pointblank library is loaded. While the framework for such testing is set up by default, the new &lt;code&gt;validate_rmd()&lt;/code&gt; function offers an opportunity to set UI and logging options.&lt;/p&gt;
&lt;p&gt;Die Verwendung von &lt;strong&gt;pointblank&lt;/strong&gt; in einem &lt;strong&gt;R Markdown&lt;/strong&gt;-Workflow ist standardmäßig aktiviert, sobald die pointblank-Bibliothek geladen ist. Während das Framework für solche Tests standardmäßig eingerichtet ist, bietet die neue Funktion &lt;code&gt;validate_rmd()&lt;/code&gt; die Möglichkeit, Benutzeroberflächen- und Protokollierungsoptionen festzulegen.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;der-agent-bericht&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Der &lt;strong&gt;agent&lt;/strong&gt; Bericht&lt;/h2&gt;
&lt;p&gt;Das Erscheinungsbild des Agentenberichts wurde erheblich verbessert und verfügt nun über einige neue Funktionen:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Datenextrakte für fehlerhafte Zeilen (in zeilenbasierten Validierungsschritten) können über die neuen Schaltflächen in der Spalte &lt;code&gt;EXT&lt;/code&gt; als CSVs heruntergeladen werden&lt;/li&gt;
&lt;li&gt;In den meisten Feldern der Tabelle gibt es nützliche QuickInfos (z. B. wenn Sie den Mauszeiger über Elemente in &lt;code&gt;STEP&lt;/code&gt; halten, wird die Kurzdarstellung angezeigt, &lt;code&gt;TBL&lt;/code&gt;-Symbole beschreiben, ob vor der Abfrage Vorbedingungen auf die Tabelle angewendet wurden usw.)&lt;/li&gt;
&lt;li&gt;Es gibt Druckverbesserungen in den Spalten &lt;code&gt;COLUMNS&lt;/code&gt; und &lt;code&gt;VALUES&lt;/code&gt; (z. B. werden Tabellenspalten von Literalwerten unterschieden).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hier ist ein Diagramm:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/agent_report.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Das ist alles sehr wichtig. Erwarten Sie weitere Verbesserungen in einer kommenden Version.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;verbesserungen-an-der-funktion-scan_data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Verbesserungen an der Funktion &lt;code&gt;scan_data()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Diese Funktion &lt;code&gt;scan_data()&lt;/code&gt; generiert einen HTML-Bericht, in dem die Daten der Eingabetabelle erläutert werden. Es ist gut zu verwenden, bevor Sie die Daten validieren. Mit dieser Funktion können wir die Daten jetzt schnell und präzise verstehen. Die Berichtsausgabe enthält mehrere Abschnitte, um alles besser verdaulich zu machen. Diese sind:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Übersicht: Tabellenabmessungen, doppelte Zeilenanzahl, Spaltentypen und Informationen zur Reproduzierbarkeit&lt;/li&gt;
&lt;li&gt;Variablen: Eine Zusammenfassung für jede Tabellenvariable sowie weitere Statistiken und Zusammenfassungen je nach Variablentyp&lt;/li&gt;
&lt;li&gt;Interaktionen: Ein Matrixdiagramm, das Interaktionen zwischen Variablen zeigt&lt;/li&gt;
&lt;li&gt;Korrelationen: Eine Reihe von Korrelationsmatrixdiagrammen für numerische Variablen&lt;/li&gt;
&lt;li&gt;Fehlende Werte: Eine zusammenfassende Abbildung, die den Grad des Fehlens zwischen Variablen und zeigt&lt;/li&gt;
&lt;li&gt;Beispiel: Eine Tabelle, die die Kopf- und Endzeilen des Datensatzes enthält&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/table_scan.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Es ist prima. Probieren Sie es mit Ihrem Lieblingsdatensatz aus. Ich habe einige Beispiele in verschiedenen Sprachen in &lt;strong&gt;RPubs&lt;/strong&gt; erstellt:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_english&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=English&amp;amp;color=blue&#34; alt=&#34;Table Scan in English&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_french&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=French&amp;amp;color=blue&#34; alt=&#34;Table Scan in French&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_german&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=German&amp;amp;color=blue&#34; alt=&#34;Table Scan in German&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_italian&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=Italian&amp;amp;color=blue&#34; alt=&#34;Table Scan in Italian&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/pointblank_storms_spanish&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=Spanish&amp;amp;color=blue&#34; alt=&#34;Table Scan in Spanish&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Alle diese Beispiele verwenden den Datensatz &lt;code&gt;dplyr::storms&lt;/code&gt;. Datenbanktabellen? Das ist die neue Verbesserung. Sie können jetzt &lt;code&gt;scan_data()&lt;/code&gt; für Datenbanktabellen verwenden. Hier sind zwei neue Beispiele, die die Tabelle &lt;code&gt;full_region&lt;/code&gt; der &lt;strong&gt;Rfam&lt;/strong&gt;-Datenbank (öffentlich gehostet unter “mysql-rfam-public.ebi.ac.uk”) und die &lt;code&gt;assembly&lt;/code&gt;-Tabelle des &lt;strong&gt;Ensembl&lt;/strong&gt; verwenden. Datenbank (öffentlich gehostet unter “ensembldb.ensembl.org”).&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://rpubs.com/rich_i/rfam_full_region&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=Rfam:%20full_region&amp;amp;color=green&#34; alt=&#34;Rfam: full_region&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://rpubs.com/rich_i/ensembl_assembly&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Table%20Scan&amp;amp;message=Ensembl:%20assembly&amp;amp;color=green&#34; alt=&#34;Ensembl: assembly&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;besseres-erscheinungsbild-für-e-mail&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Besseres Erscheinungsbild für E-Mail&lt;/h2&gt;
&lt;p&gt;Sie können eine HTML-E-Mail mit dem Bericht des Agenten senden. Dies wird durch das &lt;strong&gt;blastula&lt;/strong&gt;-Paket unterstützt. Der Anpassbarkeit des Nachrichtentexts sind keine wirklichen Grenzen gesetzt, da die Funktion &lt;code&gt;email_blast()&lt;/code&gt; nach der Abfrage vollen Zugriff auf Informationen hat. Weitere Informationen finden Sie im Hilfeartikel unter &lt;code&gt;?email_blast&lt;/code&gt;. Manchmal möchten Sie jedoch eine gute Standard-E-Mail, deren Erstellung nicht viel Arbeit erfordert. In dieser Version sieht das Standard-Erscheinungsbild der E-Mail viel besser aus.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-24-pointblank-0-4_files/pointblank_email.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Hierbei wird eine kleine Version des Agentenberichts (575 Pixel breit) verwendet, die noch QuickInfos enthält, die &lt;em&gt;briefs&lt;/em&gt; enthalten (ein schlecht gewählter englischer Name für die Kurzbeschreibungen der einzelnen Validierungsschritte). Sie können die E-Mail selbst mit den Argumenten &lt;code&gt;msg_header&lt;/code&gt;, &lt;code&gt;msg_body&lt;/code&gt; und &lt;code&gt;msg_footer&lt;/code&gt; anpassen. Möglicherweise möchten Sie dies jetzt jedoch nicht tun.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;abschließend&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Abschließend&lt;/h2&gt;
&lt;p&gt;Ich hoffe, dies gibt einen Einblick in das, worum es bei &lt;a href=&#34;https://rich-iannone.github.io/pointblank/&#34;&gt;&lt;strong&gt;pointblank&lt;/strong&gt;&lt;/a&gt; geht und wohin seine Entwicklung geht. Abgesehen von diesen beträchtlichen Verbesserungen und neuen Funktionen gab es auch viele Bugfixes und kleinere Änderungen. Ich hoffe, Sie haben die Möglichkeit, es an Ihren eigenen Daten auszuprobieren.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
function openLang(evt, cityName) {
var i, tabcontent, tablinks;
tabcontent = document.getElementsByClassName(&#34;tabcontent&#34;);
for (i = 0; i &lt; tabcontent.length; i++) {
tabcontent[i].style.display = &#34;none&#34;;
}
tablinks = document.getElementsByClassName(&#34;tablinks&#34;);
for (i = 0; i &lt; tablinks.length; i++) {
tablinks[i].className = tablinks[i].className.replace(&#34; active&#34;, &#34;&#34;);
}
document.getElementById(cityName).style.display = &#34;block&#34;;
evt.currentTarget.className += &#34; active&#34;;
}

// Get the element with id=&#34;defaultOpen&#34; and click on it
document.getElementById(&#34;defaultOpen&#34;).click();
&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>pointblank v0.3</title>
      <link>/post/pointblank-0-3/</link>
      <pubDate>Mon, 13 Jan 2020 00:00:00 +0000</pubDate>
      <guid>/post/pointblank-0-3/</guid>
      <description>


&lt;html&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;/post/css/style.css&#34; /&gt;
&lt;/html&gt;
&lt;html&gt;
&lt;div class=&#34;tab&#34;&gt;
&lt;button class=&#34;tablinks&#34; onclick=&#34;openLang(event, &amp;#39;English&amp;#39;)&#34; id=&#34;defaultOpen&#34;&gt;
English
&lt;/button&gt;
&lt;button class=&#34;tablinks&#34; onclick=&#34;openLang(event, &amp;#39;French&amp;#39;)&#34;&gt;
French
&lt;/button&gt;
&lt;button class=&#34;tablinks&#34; onclick=&#34;openLang(event, &amp;#39;German&amp;#39;)&#34;&gt;
German
&lt;/button&gt;
&lt;/div&gt;
&lt;/html&gt;
&lt;!-- Start English Section --&gt;
&lt;div id=&#34;English&#34; class=&#34;tabcontent&#34;&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-01-13-pointblank-0-3_files/pointblank-banner.svg&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The newest release of the &lt;strong&gt;pointblank&lt;/strong&gt; package makes it really easy to validate your data with workflows attuned to your data quality needs. You can install &lt;strong&gt;pointblank&lt;/strong&gt; 0.3 from CRAN with:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;pointblank&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The design goals of &lt;strong&gt;pointblank&lt;/strong&gt; are to enable two important data validation workflows with a common set of validation step functions, and, to have the code work seamlessly with data in local data tables and with database tables.&lt;/p&gt;
&lt;p&gt;The two dominant workflows that pointblank enables are:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;data quality reporting&lt;/li&gt;
&lt;li&gt;pipeline-based data validation&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-01-13-pointblank-0-3_files/two_different_workflows.png&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The first workflow is concerned with the data quality of the target table. One would use validation step functions to create a validation plan. That plan results in an interrogation of the table data. Finally, we get a report of the interrogation to ascertain data quality. The key is to use a large number of validation step functions to reveal inconsistencies or errors in the table.&lt;/p&gt;
&lt;p&gt;The second workflow is useful in a data-transformation pipeline that uses tabular data. The validation functions are used directly with data to either warn us of unforeseen data integrity problems or to completely stop the pipeline. Stopping is a good idea when dependent, downstream processes (that would use the data to some extent) would be compromised by bad data. Both workflows use a common set of validation step functions, ‘action levels’ (i.e., failure thresholds) can be set in a stepwise manner. Additionally, we can choose to use our own &lt;strong&gt;R&lt;/strong&gt; functions to create side effects like logging.&lt;/p&gt;
&lt;p&gt;Both workflows make use of a large collection of simple validation step functions. These functions are named such that it’s obvious what the validation does. For example, the &lt;code&gt;col_vals_gt()&lt;/code&gt; function tests whether cell values in a column are greater than a specified value. The interface for each step function is consistent but also optimized for the particular operation.&lt;/p&gt;
&lt;h2 id=&#34;a-walkthrough-of-pointblank-in-the-data-quality-reporting-workflow&#34;&gt;A Walkthrough of &lt;strong&gt;pointblank&lt;/strong&gt; in the Data Quality Reporting Workflow&lt;/h2&gt;
&lt;p&gt;To determine the level of data quality for a table we use something called an &lt;em&gt;agent&lt;/em&gt;. It develops a validation plan, performs the interrogation, and holds information about that interrogation (we would then ask for a report). The &lt;code&gt;create_agent()&lt;/code&gt; function is used to create the &lt;em&gt;agent&lt;/em&gt;. The target table is given to the &lt;em&gt;agent&lt;/em&gt; and the table can be a tibble or a &lt;code&gt;tbl_dbi&lt;/code&gt; object that’s made through a database connection and the &lt;code&gt;dplyr::tbl()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;We use validation step functions to build a validation plan. There are 23 of them and some check for the existence or the type of column (&lt;code&gt;col_exists()&lt;/code&gt; or the group of &lt;code&gt;col_is_*()&lt;/code&gt; functions) whereas others perform a check in each table cell within a column (e.g., all of the &lt;code&gt;col_vals_*()&lt;/code&gt; functions). We apply our own understanding of the data in the target table when using the &lt;strong&gt;pointblank&lt;/strong&gt; step functions, and, we use as many as is necessary for adequate testing.&lt;/p&gt;
&lt;p&gt;After using validation step functions to create a validation plan, the &lt;code&gt;interrogate()&lt;/code&gt; function should then be used. With that, the table will be interrogated and the necessary validation information will be stored in the &lt;em&gt;agent&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;pointblank&lt;/strong&gt; package contains a dataset called &lt;code&gt;small_table&lt;/code&gt; which is indeed small but ideal for simple examples:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;small_table&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; # A tibble: 13 x 8
#&amp;gt;    date_time           date           a b             c      d e     f    
#&amp;gt;    &amp;lt;dttm&amp;gt;              &amp;lt;date&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt;
#&amp;gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&amp;gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&amp;gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&amp;gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&amp;gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&amp;gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&amp;gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&amp;gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&amp;gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&amp;gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&amp;gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&amp;gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&amp;gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The validation plan for this table uses the following assertions:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;the &lt;code&gt;date_time&lt;/code&gt; column is a &lt;code&gt;POSIXct&lt;/code&gt; date-time column&lt;/li&gt;
&lt;li&gt;column &lt;code&gt;f&lt;/code&gt; contains only the values &lt;code&gt;&#34;low&#34;&lt;/code&gt;, &lt;code&gt;&#34;mid&#34;&lt;/code&gt;, and &lt;code&gt;&#34;high&#34;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the values in column &lt;code&gt;a&lt;/code&gt; are all less than &lt;code&gt;10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The strings in column &lt;code&gt;b&lt;/code&gt; conform to a specified regex pattern&lt;/li&gt;
&lt;li&gt;column &lt;code&gt;d&lt;/code&gt; has values in the range of &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;5000&lt;/code&gt; (this is not entirely true!)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here is the code for the above validation logic:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;agent &amp;lt;- 
  small_table %&amp;gt;%
  create_agent() %&amp;gt;%
  col_is_posix(vars(date_time)) %&amp;gt;%
  col_vals_in_set(vars(f), set = c(&amp;quot;low&amp;quot;, &amp;quot;mid&amp;quot;, &amp;quot;high&amp;quot;)) %&amp;gt;%
  col_vals_lt(vars(a), value = 10) %&amp;gt;%
  col_vals_regex(vars(b), regex = &amp;quot;^[0-9]-[a-z]{3}-[0-9]{3}$&amp;quot;) %&amp;gt;%
  col_vals_between(vars(d), left = 0, right = 5000) %&amp;gt;%
  interrogate()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;agent&lt;/code&gt; object gives us a little bit of information about how the interrogation went:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;agent&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; pointblank agent // &amp;lt;agent_2020-01-13_04:14:09&amp;gt;
#&amp;gt; 
#&amp;gt; number of validation steps: 5
#&amp;gt; 
#&amp;gt; interrogation (2020-01-13 04:14:09) resulted in:
#&amp;gt;   - 4 passing validations
#&amp;gt;   - 1 failing validation   more info: `get_agent_report()`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;4 passing validations&lt;/code&gt; means that all of the individual validations in four validation steps passed without any errors. One validation step failed with at least one test unit failing (each cell tested is equivalent to 1 test unit). We can generate a report with more detail by using &lt;code&gt;get_agent_report()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_agent_report(agent)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-01-13-pointblank-0-3_files/agent_report.png&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The report is a &lt;strong&gt;gt&lt;/strong&gt; table, which is printed by default if we have the &lt;strong&gt;gt&lt;/strong&gt; package installed (use &lt;code&gt;remotes::install_github(&#34;rstudio/gt&#34;)&lt;/code&gt; to install that package). The first five columns of the report are recognizable since they are names of the validation step functions and their parameters. The &lt;code&gt;preconditions?&lt;/code&gt; column indicates whether the table was altered just before interrogation (for that validation step). The &lt;code&gt;Units&lt;/code&gt; column shows us the total number of test units for each validation step. The &lt;code&gt;n_pass&lt;/code&gt; column gives the number of passing test units while the &lt;code&gt;f_pass&lt;/code&gt; column indicates the fraction of passing test units. The &lt;code&gt;W&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt; indicators tell us whether we have entered either of the &lt;code&gt;WARN&lt;/code&gt;, &lt;code&gt;STOP&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt; states for these validation steps. Because we didn’t set any threshold levels for these states, they are irrelevant for this report. Finally, the &lt;code&gt;Extract&lt;/code&gt; indicator tells us whether there are data extracts available for failed test units. For &lt;code&gt;step 5&lt;/code&gt;, the &lt;code&gt;col_vals_between()&lt;/code&gt; validation step, there is a data extract available. We can have a look at that extract with &lt;code&gt;get_data_extracts()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_data_extracts(agent, i = 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; # A tibble: 1 x 8
#&amp;gt;   date_time           date           a b             c      d e     f    
#&amp;gt;   &amp;lt;dttm&amp;gt;              &amp;lt;date&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt;
#&amp;gt; 1 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Recall that validation &lt;code&gt;step 5&lt;/code&gt; asserted that all values in column &lt;code&gt;d&lt;/code&gt; should be between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;5000&lt;/code&gt;, however, this extract of &lt;code&gt;small_table&lt;/code&gt; shows that column &lt;code&gt;d&lt;/code&gt; has a value that lies outside this specified range.&lt;/p&gt;
&lt;h2 id=&#34;a-walkthrough-of-pointblank-in-the-pipeline-based-data-validation-workflow&#34;&gt;A Walkthrough of &lt;strong&gt;pointblank&lt;/strong&gt; in the Pipeline-based Data Validation Workflow&lt;/h2&gt;
&lt;p&gt;The second workflow, pipeline-based data validations, somewhat simplifies the process for checking data directly. There is no &lt;em&gt;agent&lt;/em&gt; involved here and we instead call validation step functions directly on the data table objects. Because there isn’t an agent, there won’t be a report either. The idea is that the side effects are most important here (the data will pass through the validation functions unchanged). We can trigger warnings, raise errors, or write out logs when exceeding specified failure thresholds.&lt;/p&gt;
&lt;p&gt;Where would we do this? When importing data we could test that data by passing it through a few validation step functions with &lt;code&gt;warn_at&lt;/code&gt; and &lt;code&gt;stop_at&lt;/code&gt; threshold levels set. If we were to transform a data table, we could likewise use a set of validation step functions as a QA/QC measure. If bad data quality might be bad for a downstream data product, it’s probably better to stop the process through &lt;strong&gt;pointblank&lt;/strong&gt; validation tests and then do root-cause analysis to fix the data quality problem.&lt;/p&gt;
&lt;p&gt;Let’s use the statements from the previous example to work within the pipeline-based data validation workflow. In this case, we’ll use a simple call of the &lt;code&gt;action_levels()&lt;/code&gt; function to generate the &lt;code&gt;al&lt;/code&gt; object. It’s passed to the &lt;code&gt;actions&lt;/code&gt; argument of every validaton step function. The setting implies that the pipeline will be stopped when there is a single test unit failure (with &lt;code&gt;stop_at = 1&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Create an `action_levels` object, stopping the pipeline
# if we get a single failing test unit
al &amp;lt;- action_levels(stop_at = 1)

small_table %&amp;gt;%
  col_is_posix(vars(date_time), actions = al) %&amp;gt;%
  col_vals_in_set(vars(f), set = c(&amp;quot;low&amp;quot;, &amp;quot;mid&amp;quot;, &amp;quot;high&amp;quot;), actions = al) %&amp;gt;%
  col_vals_lt(vars(a), value = 10, actions = al) %&amp;gt;%
  col_vals_regex(vars(b), regex = &amp;quot;^[0-9]-[a-z]{3}-[0-9]{3}$&amp;quot;, actions = al) %&amp;gt;%
  col_vals_between(vars(d), left = 0, right = 5000, actions = al)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Error: The validation (`col_vals_between()`) meets or exceeds the stop threshold&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is one of those times when we might be glad to see an error. The threshold setting stopped the evaluation of the pipeline and, in turn, stops the running script if it’s deployed and automatically running on the regular. The &lt;code&gt;action_levels()&lt;/code&gt; function is quite powerful and it allows us to define custom functions that are evaluated when entering each of the three failure states. In this type of workflow we don’t need to define those functions, pointblank will automatically do the sensible thing and provide a stock &lt;code&gt;warning()&lt;/code&gt; or &lt;code&gt;stop()&lt;/code&gt; message.&lt;/p&gt;
&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;These short demonstrations show the main features of the two data validation workflows of &lt;strong&gt;pointblank&lt;/strong&gt;. There are many things you can do to precisely define the validation steps and to cause the correct action to occur when entering different failure states. I hope you’re inclined to try it out on your own data!&lt;/p&gt;
&lt;/div&gt;
&lt;!-- Start French Section --&gt;
&lt;div id=&#34;French&#34; class=&#34;tabcontent&#34;&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-01-13-pointblank-0-3_files/pointblank-banner.svg&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;La dernière version du package &lt;strong&gt;pointblank&lt;/strong&gt; facilite la validation de vos données avec des workflows adaptés à vos besoins en matière de qualité des données. Vous pouvez installer pointblank 0.3 avec:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;pointblank&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;L’objectif de conception de pointblank est de permettre deux workflows de validation de données importants avec un ensemble commun de fonctions d’étape de validation et le code écrit devrait fonctionner de manière transparente avec les données des tables de données locales et avec les données des bases de données.&lt;/p&gt;
&lt;p&gt;Les deux workflows dominants que permet pointblank sont:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;rapports sur la qualité des données&lt;/li&gt;
&lt;li&gt;validations de données basées sur le pipeline&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-01-13-pointblank-0-3_files/two_different_workflows.png&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Le premier workflow concerne la qualité des données de la table cible. On utiliserait des fonctions d’étape de validation pour créer un plan de validation. Ce plan entraîne une interrogation des données de la table. Enfin, nous obtenons un rapport de l’interrogation pour vérifier la qualité des données. L’idée principale est d’utiliser un grand nombre de fonctions d’étape de validation pour révéler des incohérences ou des erreurs dans le tableau de données.&lt;/p&gt;
&lt;p&gt;La deuxième méthodologie est utile dans un pipeline de transformation de données qui utilise des données tabulaires. Les fonctions de validation sont utilisées directement pour nous avertir des problèmes imprévus d’intégrité des données ou pour arrêter complètement le pipeline. L’arrêt est une bonne idée lorsque les processus dépendants et en aval (qui utiliseraient les données dans une certaine mesure) seraient compromis par de mauvaises données. Les deux méthodologies utilisent un ensemble commun de fonctions d’étape de validation, les «action levels» (c’est-à-dire les seuils d’échec) peuvent être définis par étapes. De plus, nous pouvons choisir d’utiliser nos propres fonctions &lt;strong&gt;R&lt;/strong&gt; pour créer des effets secondaires comme la journalisation.&lt;/p&gt;
&lt;p&gt;Les deux workflows utilisent une large collection de fonctions d’étape de validation simples. Ces fonctions sont nommées de telle sorte que la fonction de validation soit évidente. Par exemple, la fonction &lt;code&gt;col_vals_gt()&lt;/code&gt; teste si les valeurs de cellule dans une colonne sont supérieures à une valeur spécifiée. L’interface pour chaque fonction d’étape est cohérente mais également optimisée pour l’opération particulière.&lt;/p&gt;
&lt;h2 id=&#34;présentation-pas-à-pas-de-pointblank-dans-le-workflow-de-rapport-sur-la-qualité-des-données&#34;&gt;Présentation pas à pas de &lt;strong&gt;pointblank&lt;/strong&gt; dans le workflow de rapport sur la qualité des données&lt;/h2&gt;
&lt;p&gt;Pour déterminer le niveau de qualité des données d’une table, nous utilisons ce que l’on appelle un agent. Il élabore un plan de validation, effectue l’interrogatoire et détient des informations sur cette interrogation (nous demanderions alors un rapport). La fonction &lt;code&gt;create_agent()&lt;/code&gt; est utilisée pour créer l’agent. La table cible est donnée à l’agent et la table peut être un tibble ou un objet &lt;code&gt;tbl_dbi&lt;/code&gt; créé via une connexion à la base de données et la fonction &lt;code&gt;dplyr::tbl()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Nous utilisons des fonctions d’étape de validation pour construire un plan de validation. Il y en a 23 et certains vérifient l’existence ou le type de colonne (&lt;code&gt;col_exists()&lt;/code&gt; ou le groupe de fonctions de la forme: &lt;code&gt;col_is_*()&lt;/code&gt;) tandis que d’autres effectuent une vérification dans chaque cellule du tableau d’une colonne (par exemple, tous les &lt;code&gt;col_vals_*()&lt;/code&gt; fonctions). Nous appliquons notre propre compréhension des données de la table cible lors de l’utilisation des fonctions d’étape de pointblank, et nous en utilisons autant que nécessaire pour des tests adéquats.&lt;/p&gt;
&lt;p&gt;Après avoir utilisé les fonctions de l’étape de validation pour créer un plan de validation, la fonction &lt;code&gt;interrogate()&lt;/code&gt; doit ensuite être utilisée. Avec cela, la table sera interrogée et les informations de validation nécessaires seront stockées dans l’agent.&lt;/p&gt;
&lt;p&gt;Utilisons l’objet &lt;code&gt;small_table&lt;/code&gt; pour des exemples:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;small_table&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; # A tibble: 13 x 8
#&amp;gt;    date_time           date           a b             c      d e     f    
#&amp;gt;    &amp;lt;dttm&amp;gt;              &amp;lt;date&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt;
#&amp;gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&amp;gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&amp;gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&amp;gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&amp;gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&amp;gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&amp;gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&amp;gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&amp;gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&amp;gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&amp;gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&amp;gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&amp;gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Le plan de validation de ce tableau utilise les assertions suivantes:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;la colonne &lt;code&gt;date_time&lt;/code&gt; est une colonne date-heure&lt;/li&gt;
&lt;li&gt;la colonne &lt;code&gt;f&lt;/code&gt; ne contient que les valeurs &lt;code&gt;&#34;low&#34;&lt;/code&gt;, &lt;code&gt;&#34;mid&#34;&lt;/code&gt;, and &lt;code&gt;&#34;high&#34;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;les valeurs de la colonne &lt;code&gt;a&lt;/code&gt; sont toutes inférieures à &lt;code&gt;10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Les valeurs de texte dans la colonne &lt;code&gt;b&lt;/code&gt; sont conformes à un modèle spécifié&lt;/li&gt;
&lt;li&gt;la colonne &lt;code&gt;d&lt;/code&gt; a des valeurs entre &lt;code&gt;0&lt;/code&gt; et &lt;code&gt;5000&lt;/code&gt; (pas entièrement vrai!)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Voici le code pour la validation:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;agent &amp;lt;- 
  small_table %&amp;gt;%
  create_agent() %&amp;gt;%
  col_is_posix(vars(date_time)) %&amp;gt;%
  col_vals_in_set(vars(f), set = c(&amp;quot;low&amp;quot;, &amp;quot;mid&amp;quot;, &amp;quot;high&amp;quot;)) %&amp;gt;%
  col_vals_lt(vars(a), value = 10) %&amp;gt;%
  col_vals_regex(vars(b), regex = &amp;quot;^[0-9]-[a-z]{3}-[0-9]{3}$&amp;quot;) %&amp;gt;%
  col_vals_between(vars(d), left = 0, right = 5000) %&amp;gt;%
  interrogate()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;L’objet &lt;code&gt;agent&lt;/code&gt; nous donne quelques informations sur la façon dont les choses se sont passées:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;agent&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; pointblank agent // &amp;lt;agent_2020-01-13_04:14:09&amp;gt;
#&amp;gt; 
#&amp;gt; number of validation steps: 5
#&amp;gt; 
#&amp;gt; interrogation (2020-01-13 04:14:09) resulted in:
#&amp;gt;   - 4 passing validations
#&amp;gt;   - 1 failing validation   more info: `get_agent_report()`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Les «4 passing validations» signifient que toutes les validations individuelles en quatre étapes de validation ont réussi sans erreur. Une étape de validation a échoué et au moins une unité de test a échoué (chaque cellule testée équivaut à 1 unité de test). Nous pouvons générer un rapport avec plus de détails en utilisant &lt;code&gt;get_agent_report()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_agent_report(agent)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-01-13-pointblank-0-3_files/agent_report.png&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Le rapport est une table &lt;strong&gt;gt&lt;/strong&gt;, qui est imprimée par défaut si nous avons installé le paquet &lt;strong&gt;gt&lt;/strong&gt; (utilisez &lt;code&gt;remotes::install_github(&#34;rstudio/gt&#34;)&lt;/code&gt; pour installer ce paquet). Les cinq premières colonnes du rapport sont reconnaissables car ce sont les noms des fonctions de l’étape de validation et leurs paramètres. Les &lt;code&gt;preconditions&lt;/code&gt; colonne indique si la table a été modifiée juste avant l’interrogation (pour cette étape de validation). La colonne &lt;code&gt;Units&lt;/code&gt; nous indique le nombre total d’unités de test pour chaque étape de validation. La colonne &lt;code&gt;n_pass&lt;/code&gt; donne le nombre d’unités de test réussies tandis que la colonne &lt;code&gt;f_pass&lt;/code&gt; indique la fraction d’unités de test réussies. Les indicateurs &lt;code&gt;W&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt; nous indiquent si nous sommes entrés dans l’un des états &lt;code&gt;WARN&lt;/code&gt;, &lt;code&gt;STOP&lt;/code&gt; ou &lt;code&gt;NOTIFY&lt;/code&gt; pour ces étapes de validation. Étant donné que nous n’avons défini aucun seuil pour ces États, ils ne sont pas pertinents pour ce rapport. Enfin, l’indicateur &lt;code&gt;Extract&lt;/code&gt; nous indique si des extraits de données sont disponibles pour les unités de test ayant échoué. Pour &lt;em&gt;l’étape 5&lt;/em&gt;, l’étape de validation &lt;code&gt;col_vals_between()&lt;/code&gt;, un extrait de données est disponible. Nous pouvons jeter un œil à cet extrait avec &lt;code&gt;get_data_extracts()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_data_extracts(agent, i = 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; # A tibble: 1 x 8
#&amp;gt;   date_time           date           a b             c      d e     f    
#&amp;gt;   &amp;lt;dttm&amp;gt;              &amp;lt;date&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt;
#&amp;gt; 1 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rappelons que &lt;code&gt;l&#39;étape 5&lt;/code&gt; a affirmé que toutes les valeurs de la colonne &lt;code&gt;d&lt;/code&gt; doivent être comprises entre &lt;code&gt;0&lt;/code&gt; et &lt;code&gt;5000&lt;/code&gt;, cependant, cet extrait de &lt;code&gt;small_table&lt;/code&gt; montre que la colonne &lt;code&gt;d&lt;/code&gt; a une valeur qui se situe en dehors de cette plage spécifiée.&lt;/p&gt;
&lt;h2 id=&#34;procédure-pas-à-pas-de-pointblank-dans-le-workflow-de-validation-des-données-basé-sur-le-pipeline&#34;&gt;Procédure pas à pas de &lt;strong&gt;pointblank&lt;/strong&gt; dans le workflow de validation des données basé sur le pipeline&lt;/h2&gt;
&lt;p&gt;La deuxième méthodologie, la validation des données par pipeline, simplifie quelque peu le processus de vérification directe des données. Aucun &lt;em&gt;agent&lt;/em&gt; n’est impliqué ici et nous appelons plutôt les fonctions d’étape de validation directement sur les objets de la table de données. Parce qu’il n’y a pas d’agent, il n’y aura pas non plus de rapport. L’idée est que les effets secondaires sont les plus importants ici (les données passeront par les fonctions de validation inchangées). Nous pouvons déclencher des avertissements, générer des erreurs ou écrire des journaux en cas de dépassement des seuils d’échec spécifiés.&lt;/p&gt;
&lt;p&gt;Où ferions-nous cela? Lors de l’importation de données, nous pourrions tester ces données en les passant par quelques fonctions d’étape de validation avec des niveaux de seuil &lt;code&gt;warn_at&lt;/code&gt; et &lt;code&gt;stop_at&lt;/code&gt; définis. Si nous devions transformer un tableau de données, nous pourrions également utiliser un ensemble de fonctions d’étape de validation comme mesure d’AQ et de CQ. Si la mauvaise qualité des données peut être mauvaise pour un produit de données en aval, il est probablement préférable d’arrêter le processus par le biais de tests de validation &lt;strong&gt;pointblank&lt;/strong&gt;, puis d’effectuer une analyse des causes profondes pour résoudre le problème de qualité des données.&lt;/p&gt;
&lt;p&gt;Utilisons les instructions de l’exemple précédent pour travailler dans le workflow de validation des données basé sur le pipeline. Dans ce cas, nous utiliserons un simple appel de la fonction &lt;code&gt;action_levels()&lt;/code&gt; pour générer l’objet &lt;code&gt;al&lt;/code&gt;. Il est passé à l’argument &lt;code&gt;actions&lt;/code&gt; de chaque fonction d’étape de validation. Le paramètre implique que le pipeline sera arrêté en cas de défaillance d’une seule unité de test (avec &lt;code&gt;stop_at = 1&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Create an `action_levels` object, stopping the pipeline
# if we get a single failing test unit
al &amp;lt;- action_levels(stop_at = 1)

small_table %&amp;gt;%
  col_is_posix(vars(date_time), actions = al) %&amp;gt;%
  col_vals_in_set(vars(f), set = c(&amp;quot;low&amp;quot;, &amp;quot;mid&amp;quot;, &amp;quot;high&amp;quot;), actions = al) %&amp;gt;%
  col_vals_lt(vars(a), value = 10, actions = al) %&amp;gt;%
  col_vals_regex(vars(b), regex = &amp;quot;^[0-9]-[a-z]{3}-[0-9]{3}$&amp;quot;, actions = al) %&amp;gt;%
  col_vals_between(vars(d), left = 0, right = 5000, actions = al)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Error: The validation (`col_vals_between()`) meets or exceeds the stop threshold&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C’est l’un de ces moments où nous pourrions être super heureux de voir une erreur. Le paramètre de seuil a arrêté l’évaluation du pipeline et, à son tour, arrête le script en cours d’exécution s’il est déployé et s’exécute automatiquement sur la version standard. La fonction &lt;code&gt;action_levels()&lt;/code&gt; est assez puissante et elle nous permet de définir des fonctions personnalisées qui sont évaluées lors de la saisie de chacun des trois états de défaillance. Dans ce type de workflow, nous n’avons pas besoin de définir ces fonctions, &lt;strong&gt;pointblank&lt;/strong&gt; nous aidera automatiquement à cela.&lt;/p&gt;
&lt;h2 id=&#34;essayez-pointblank&#34;&gt;Essayez &lt;strong&gt;pointblank&lt;/strong&gt;!&lt;/h2&gt;
&lt;p&gt;Ces courtes démonstrations présentent les principales caractéristiques des deux workflows de validation des données de &lt;strong&gt;pointblank&lt;/strong&gt;. Il existe de nombreuses choses que vous pouvez faire pour définir précisément les étapes de validation et pour que l’action correcte se produise lors de la saisie de différents états de défaillance. J’espère que vous êtes enclin à l’essayer sur vos propres données!&lt;/p&gt;
&lt;/div&gt;
&lt;!-- Start German Section --&gt;
&lt;div id=&#34;German&#34; class=&#34;tabcontent&#34;&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-01-13-pointblank-0-3_files/pointblank-banner.svg&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Die neueste Version des &lt;strong&gt;pointblank&lt;/strong&gt;-Pakets erleichtert die Validierung Ihrer Daten mit Workflows, die auf Ihre Datenqualitätsanforderungen abgestimmt sind. Sie können &lt;strong&gt;pointblank&lt;/strong&gt; 0.3 von CRAN installieren mit:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;pointblank&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Das Entwurfsziel von &lt;strong&gt;pointblank&lt;/strong&gt; besteht darin, zwei wichtige Datenvalidierungs-Workflows mit einem gemeinsamen Satz von Validierungsschrittfunktionen zu ermöglichen. Der geschriebene Code sollte mit Daten in lokalen Datentabellen und mit Daten in Datenbanken gleichermaßen gut funktionieren.&lt;/p&gt;
&lt;p&gt;Die beiden wichtigsten Workflows, bei denen pointblank hilft, sind:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Berichterstattung zur Datenqualität&lt;/li&gt;
&lt;li&gt;Pipeline-basierte Datenvalidierungen&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-01-13-pointblank-0-3_files/two_different_workflows.png&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Der erste Workflow befasst sich mit der Datenqualität der Zieltabelle. Man würde Validierungsschrittfunktionen verwenden, um einen Validierungsplan zu erstellen. Dieser Plan führt zu einer Abfrage der Tabellendaten. Schließlich erhalten wir einen Bericht über die Abfrage, um die Datenqualität festzustellen. Es wird empfohlen, eine große Anzahl von Validierungsschrittfunktionen zu verwenden. Mit mehr von ihnen können wir Inkonsistenzen oder Fehler in der Tabelle besser aufdecken.&lt;/p&gt;
&lt;p&gt;Der zweite Workflow ist in einer Datentransformationspipeline nützlich, die Tabellendaten verwendet. Die Validierungsfunktionen werden direkt verwendet, um uns entweder vor unvorhergesehenen Problemen mit der Datenintegrität zu warnen oder um die Pipeline vollständig zu stoppen. Anhalten ist eine gute Idee, wenn abhängige, nachgelagerte Prozesse (die die Daten in gewissem Umfang nutzen würden) durch schlechte Daten beeinträchtigt würden. Beide Workflows verwenden einen gemeinsamen Satz von Validierungsschrittfunktionen. “Action levels” (d. H. Fehlerschwellen) können schrittweise festgelegt werden. Zusätzlich können wir unsere eigenen &lt;strong&gt;R&lt;/strong&gt;-Funktionen verwenden, um Nebenwirkungen wie das Schreiben von Protokolldateien zu erzeugen.&lt;/p&gt;
&lt;p&gt;Beide Workflows verwenden eine große Sammlung einfacher Validierungsschrittfunktionen. Diese Funktionen werden so benannt, dass es offensichtlich ist, was die Validierung bewirkt. Beispielsweise testet die Funktion &lt;code&gt;col_vals_gt()&lt;/code&gt;, ob die Zellenwerte in einer Spalte größer als ein angegebener Wert sind. Die Schnittstelle für jede Schrittfunktion ist konsistent, aber auch für die jeweilige Operation optimiert.&lt;/p&gt;
&lt;h2 id=&#34;exemplarische-vorgehensweise-von-pointblank-im-workflow-für-die-berichterstellung-zur-datenqualität&#34;&gt;Exemplarische Vorgehensweise von &lt;strong&gt;pointblank&lt;/strong&gt; im Workflow für die Berichterstellung zur Datenqualität&lt;/h2&gt;
&lt;p&gt;Um die Datenqualität für eine Tabelle zu bestimmen, verwenden wir einen Agenten. Es entwickelt einen Validierungsplan, führt die Befragung durch und enthält Informationen zu dieser Befragung (wir würden dann um einen Bericht bitten). Mit der Funktion &lt;code&gt;create_agent()&lt;/code&gt; wird der Agent erstellt. Die Zieltabelle wird dem Agenten übergeben, und die Tabelle kann ein tibble- oder ein &lt;code&gt;tbl_dbi&lt;/code&gt;-Objekt sein, das über eine Datenbankverbindung und die Funktion &lt;code&gt;dplyr::tbl()&lt;/code&gt; erstellt wurde.&lt;/p&gt;
&lt;p&gt;Wir verwenden Validierungsschrittfunktionen, um einen Validierungsplan zu erstellen. Es gibt 23 von ihnen und einige prüfen die Existenz oder den Typ der Spalte (&lt;code&gt;col_exists()&lt;/code&gt; oder die Gruppe von &lt;code&gt;col_is_*()&lt;/code&gt; -Funktionen), während andere eine Prüfung in jeder Tabellenzelle innerhalb einer Spalte durchführen (z. B. alle &lt;code&gt;col_vals_*()&lt;/code&gt; Funktionen). Wir wenden bei der Verwendung der Pointblank-Step-Funktionen unser eigenes Verständnis der Daten in der Zieltabelle an und verwenden so viele, wie für angemessene Tests erforderlich sind.&lt;/p&gt;
&lt;p&gt;Nachdem Sie Validierungsschrittfunktionen zum Erstellen eines Validierungsplans verwendet haben, sollte die Funktion &lt;code&gt;interrogate()&lt;/code&gt; verwendet werden. Damit wird die Tabelle abgefragt und die notwendigen Validierungsinformationen im Agenten gespeichert.&lt;/p&gt;
&lt;p&gt;Das &lt;strong&gt;pointblank&lt;/strong&gt;-Paket enthält einen Datensatz mit dem Namen &lt;code&gt;small_table&lt;/code&gt;. Wir werden es für alle kommenden Beispiele verwenden:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;small_table&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; # A tibble: 13 x 8
#&amp;gt;    date_time           date           a b             c      d e     f    
#&amp;gt;    &amp;lt;dttm&amp;gt;              &amp;lt;date&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt;
#&amp;gt;  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high 
#&amp;gt;  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low  
#&amp;gt;  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high 
#&amp;gt;  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid  
#&amp;gt;  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low  
#&amp;gt;  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid  
#&amp;gt;  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high 
#&amp;gt;  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low  
#&amp;gt;  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&amp;gt; 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high 
#&amp;gt; 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low  
#&amp;gt; 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low  
#&amp;gt; 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Der Validierungsplan für diese Tabelle verwendet die folgenden Zusicherungen:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Die Spalte &lt;code&gt;date_time&lt;/code&gt; ist eine Datum-Uhrzeit-Spalte&lt;/li&gt;
&lt;li&gt;Spalte &lt;code&gt;f&lt;/code&gt; enthält nur die Werte &lt;code&gt;&#34;low&#34;&lt;/code&gt;, &lt;code&gt;&#34;mid&#34;&lt;/code&gt; und &lt;code&gt;&#34;high&#34;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Die Werte in Spalte &lt;code&gt;a&lt;/code&gt; sind alle kleiner als &lt;code&gt;10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Die Zeichenfolgen in Spalte &lt;code&gt;b&lt;/code&gt; entsprechen einem angegebenen regulären Ausdruck&lt;/li&gt;
&lt;li&gt;Spalte &lt;code&gt;d&lt;/code&gt; hat Werte im Bereich von &lt;code&gt;0&lt;/code&gt; bis &lt;code&gt;5000&lt;/code&gt; (dies ist nicht ganz richtig!)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hier ist der Code für die obige Validierungslogik:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;agent &amp;lt;- 
  small_table %&amp;gt;%
  create_agent() %&amp;gt;%
  col_is_posix(vars(date_time)) %&amp;gt;%
  col_vals_in_set(vars(f), set = c(&amp;quot;low&amp;quot;, &amp;quot;mid&amp;quot;, &amp;quot;high&amp;quot;)) %&amp;gt;%
  col_vals_lt(vars(a), value = 10) %&amp;gt;%
  col_vals_regex(vars(b), regex = &amp;quot;^[0-9]-[a-z]{3}-[0-9]{3}$&amp;quot;) %&amp;gt;%
  col_vals_between(vars(d), left = 0, right = 5000) %&amp;gt;%
  interrogate()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Das &lt;code&gt;Agent&lt;/code&gt;-Objekt gibt uns ein paar Informationen über die Befragung:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;agent&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; pointblank agent // &amp;lt;agent_2020-01-13_04:14:09&amp;gt;
#&amp;gt; 
#&amp;gt; number of validation steps: 5
#&amp;gt; 
#&amp;gt; interrogation (2020-01-13 04:14:09) resulted in:
#&amp;gt;   - 4 passing validations
#&amp;gt;   - 1 failing validation   more info: `get_agent_report()`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Die &lt;code&gt;4 passing validations&lt;/code&gt; bedeuten, dass alle Einzelvalidierungen in vier Validierungsschritten fehlerfrei bestanden wurden. Ein Validierungsschritt ist fehlgeschlagen, wobei mindestens eine Testeinheit ausgefallen ist (jede getestete Zelle entspricht 1 Testeinheit). Mit &lt;code&gt;get_agent_report()&lt;/code&gt; können wir einen detaillierteren Bericht erstellen:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_agent_report(agent)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-01-13-pointblank-0-3_files/agent_report.png&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Der Bericht ist eine &lt;strong&gt;gt&lt;/strong&gt;-Tabelle, die standardmäßig gedruckt wird, wenn das &lt;strong&gt;gt&lt;/strong&gt;-Paket installiert ist (verwenden Sie &lt;code&gt;remotes::install_github(&#34;rstudio/gt&#34;)&lt;/code&gt;, um dieses Paket zu installieren). Die ersten fünf Spalten des Berichts sind erkennbar, da sie Namen der Validierungsschrittfunktionen und ihrer Parameter sind. Die Spalte &lt;code&gt;preconditions?&lt;/code&gt; gibt an, ob die Tabelle unmittelbar vor der Abfrage geändert wurde (für diesen Validierungsschritt). In der Spalte &lt;code&gt;Units&lt;/code&gt; wird die Gesamtzahl der Testeinheiten für jeden Validierungsschritt angezeigt. Die Spalte &lt;code&gt;n_pass&lt;/code&gt; gibt die Anzahl der bestandenen Testeinheiten an, während die Spalte &lt;code&gt;f_pass&lt;/code&gt; den Anteil der bestandenen Testeinheiten angibt. Die &lt;code&gt;W&lt;/code&gt;-, &lt;code&gt;S&lt;/code&gt;- und &lt;code&gt;N&lt;/code&gt;-Anzeigen zeigen an, ob wir für diese Überprüfungsschritte einen der Zustände &lt;code&gt;WARN&lt;/code&gt;, &lt;code&gt;STOP&lt;/code&gt; oder &lt;code&gt;NOTIFY&lt;/code&gt; eingegeben haben. Da wir für diese Staaten keine Schwellenwerte festgelegt haben, sind sie für diesen Bericht nicht relevant. Schließlich gibt der Indikator &lt;code&gt;Extract&lt;/code&gt; Auskunft darüber, ob für fehlerhafte Testeinheiten Datenextrakte verfügbar sind. Für &lt;code&gt;step 5&lt;/code&gt;, den Validierungsschritt &lt;code&gt;col_vals_between()&lt;/code&gt;, steht ein Datenextrakt zur Verfügung. Wir können uns diesen Auszug mit &lt;code&gt;get_data_extracts()&lt;/code&gt; ansehen:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_data_extracts(agent, i = 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; # A tibble: 1 x 8
#&amp;gt;   date_time           date           a b             c      d e     f    
#&amp;gt;   &amp;lt;dttm&amp;gt;              &amp;lt;date&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt;
#&amp;gt; 1 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Denken Sie daran, dass bei der Validierung in &lt;code&gt;step 5&lt;/code&gt; festgestellt wurde, dass alle Werte in Spalte &lt;code&gt;d&lt;/code&gt; zwischen &lt;code&gt;0&lt;/code&gt; und &lt;code&gt;5000&lt;/code&gt; liegen sollten. Dieser Auszug aus &lt;code&gt;small_table&lt;/code&gt; zeigt jedoch, dass Spalte &lt;code&gt;d&lt;/code&gt; einen Wert hat, der außerhalb des angegebenen Bereichs liegt.&lt;/p&gt;
&lt;h2 id=&#34;eine-exemplarische-vorgehensweise-für-pointblank-im-pipeline-basierten-datenüberprüfungs-workflow&#34;&gt;Eine exemplarische Vorgehensweise für &lt;strong&gt;pointblank&lt;/strong&gt; im Pipeline-basierten Datenüberprüfungs-Workflow&lt;/h2&gt;
&lt;p&gt;Der zweite Workflow, die pipelinebasierte Datenüberprüfung, vereinfacht die direkte Überprüfung der Daten ein wenig. Hier ist kein &lt;em&gt;Agent&lt;/em&gt; beteiligt. Stattdessen rufen wir Validierungsschrittfunktionen direkt auf den Datentabellenobjekten auf. Da es keinen Agenten gibt, wird es auch keinen Bericht geben. Die Idee ist, dass die Nebenwirkungen hier am wichtigsten sind (die Daten durchlaufen die Validierungsfunktionen unverändert). Wir können Warnungen auslösen, Fehler auslösen oder Protokolle ausschreiben, wenn bestimmte Fehlerschwellen überschritten werden.&lt;/p&gt;
&lt;p&gt;Wo würden wir das machen? Beim Importieren von Daten konnten wir diese Daten testen, indem wir einige Validierungsschrittfunktionen mit festgelegten Schwellenwerten für &lt;code&gt;warn_at&lt;/code&gt; und &lt;code&gt;stop_at&lt;/code&gt; durchliefen. Wenn wir eine Datentabelle transformieren würden, könnten wir ebenfalls eine Reihe von Validierungsschrittfunktionen als QA / QC-Maß verwenden. Wenn eine schlechte Datenqualität für ein nachgeschaltetes Datenprodukt schlecht sein könnte, ist es wahrscheinlich besser, den Prozess durch &lt;strong&gt;pointblank&lt;/strong&gt;-Validierungstests zu stoppen und anschließend eine Ursachenanalyse durchzuführen, um das Datenqualitätsproblem zu beheben.&lt;/p&gt;
&lt;p&gt;Verwenden Sie die Anweisungen aus dem vorherigen Beispiel, um im Workflow für die pipelinebasierte Datenüberprüfung zu arbeiten. In diesem Fall verwenden wir einen einfachen Aufruf der &lt;code&gt;action_levels()&lt;/code&gt; -Funktion, um das al-Objekt zu generieren. Es wird an das Argument &lt;code&gt;actions&lt;/code&gt; jeder Validierungsschrittfunktion übergeben. Die Einstellung impliziert, dass die Pipeline gestoppt wird, wenn eine einzelne Testeinheit ausfällt (mit &lt;code&gt;stop_at = 1&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Create an `action_levels` object, stopping the pipeline
# if we get a single failing test unit
al &amp;lt;- action_levels(stop_at = 1)

small_table %&amp;gt;%
  col_is_posix(vars(date_time), actions = al) %&amp;gt;%
  col_vals_in_set(vars(f), set = c(&amp;quot;low&amp;quot;, &amp;quot;mid&amp;quot;, &amp;quot;high&amp;quot;), actions = al) %&amp;gt;%
  col_vals_lt(vars(a), value = 10, actions = al) %&amp;gt;%
  col_vals_regex(vars(b), regex = &amp;quot;^[0-9]-[a-z]{3}-[0-9]{3}$&amp;quot;, actions = al) %&amp;gt;%
  col_vals_between(vars(d), left = 0, right = 5000, actions = al)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Error: The validation (`col_vals_between()`) meets or exceeds the stop threshold&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dies ist eine der Situationen, in denen wir uns möglicherweise über einen Fehler freuen. Die Schwellenwerteinstellung hat die Auswertung der Pipeline gestoppt und stoppt das ausgeführte Skript, wenn es bereitgestellt wird und automatisch regelmäßig ausgeführt wird. Die &lt;code&gt;action_levels()&lt;/code&gt;-Funktion ist sehr leistungsfähig und ermöglicht es uns, benutzerdefinierte Funktionen zu definieren, die beim Eingeben der drei Fehlerzustände ausgewertet werden. In dieser Art von Workflow müssen diese Funktionen nicht definiert werden. Pointblank erledigt automatisch die sinnvolle Aufgabe und gibt eine &lt;code&gt;warning()&lt;/code&gt; oder eine &lt;code&gt;stop()&lt;/code&gt;-Meldung aus.&lt;/p&gt;
&lt;h2 id=&#34;bitte-testen-sie-das-pointblank-paket&#34;&gt;Bitte testen Sie das &lt;strong&gt;pointblank&lt;/strong&gt;-Paket&lt;/h2&gt;
&lt;p&gt;Diese kurzen Demonstrationen zeigen die Hauptmerkmale der beiden Datenvalidierungs-Workflows von &lt;strong&gt;pointblank&lt;/strong&gt;. Es gibt viele Möglichkeiten, um die Überprüfungsschritte genau zu definieren und die richtige Aktion auszulösen, wenn verschiedene Fehlerzustände eingegeben werden. Ich hoffe, Sie sind geneigt, es an Ihren eigenen Daten auszuprobieren!&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
function openLang(evt, cityName) {
var i, tabcontent, tablinks;
tabcontent = document.getElementsByClassName(&#34;tabcontent&#34;);
for (i = 0; i &lt; tabcontent.length; i++) {
tabcontent[i].style.display = &#34;none&#34;;
}
tablinks = document.getElementsByClassName(&#34;tablinks&#34;);
for (i = 0; i &lt; tablinks.length; i++) {
tablinks[i].className = tablinks[i].className.replace(&#34; active&#34;, &#34;&#34;);
}
document.getElementById(cityName).style.display = &#34;block&#34;;
evt.currentTarget.className += &#34; active&#34;;
}

// Get the element with id=&#34;defaultOpen&#34; and click on it
document.getElementById(&#34;defaultOpen&#34;).click();
&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>blastula v0.3</title>
      <link>/post/blastula-0-3/</link>
      <pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate>
      <guid>/post/blastula-0-3/</guid>
      <description>


&lt;html&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;/post/css/style.css&#34; /&gt;
&lt;/html&gt;
&lt;html&gt;
&lt;div class=&#34;tab&#34;&gt;
&lt;button class=&#34;tablinks&#34; onclick=&#34;openLang(event, &amp;#39;English&amp;#39;)&#34; id=&#34;defaultOpen&#34;&gt;
English
&lt;/button&gt;
&lt;button class=&#34;tablinks&#34; onclick=&#34;openLang(event, &amp;#39;French&amp;#39;)&#34;&gt;
French
&lt;/button&gt;
&lt;button class=&#34;tablinks&#34; onclick=&#34;openLang(event, &amp;#39;German&amp;#39;)&#34;&gt;
German
&lt;/button&gt;
&lt;/div&gt;
&lt;/html&gt;
&lt;!-- Start English Section --&gt;
&lt;div id=&#34;English&#34; class=&#34;tabcontent&#34;&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-20-blastula-0-3_files/blastula-banner.svg&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The newest release of the &lt;strong&gt;blastula&lt;/strong&gt; package lets you to do amazing things with HTML email in &lt;strong&gt;R&lt;/strong&gt; and &lt;strong&gt;RStudio Connect&lt;/strong&gt;. You can install &lt;strong&gt;blastula&lt;/strong&gt; 0.3 from CRAN with:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;blastula&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a huge release! There are so many new and improved features we won’t be able to get through all of them here. Let’s focus on just two: &lt;strong&gt;R Markdown&lt;/strong&gt; report emailing and improved HTML emailing using SMTP.&lt;/p&gt;
&lt;h2 id=&#34;r-markdown-report-emailing-via-rstudio-connect&#34;&gt;&lt;strong&gt;R Markdown&lt;/strong&gt; Report Emailing via &lt;strong&gt;RStudio Connect&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;The capability to email a rendered &lt;strong&gt;R Markdown&lt;/strong&gt; document in &lt;strong&gt;RStudio Connect&lt;/strong&gt; has been available for well over a year. What would happen is that the report would be in the form of an attachment and message portion of the email would be prepared largely by &lt;strong&gt;RStudio Connect&lt;/strong&gt;. With &lt;strong&gt;blastula&lt;/strong&gt; v0.3, we can now create an email message body directly with &lt;strong&gt;R Markdown&lt;/strong&gt;. Moreover, we can have a ‘main’ report for &lt;strong&gt;RStudio Connect&lt;/strong&gt; viewers (with all of the details) and an ‘email’ version of the report that contains only the necessary elements for the purposes of email.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-20-blastula-0-3_files/old_versus_new_rsc.png&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Static elements like &lt;strong&gt;ggplot&lt;/strong&gt;s and images can be part of the &lt;strong&gt;R Markdown&lt;/strong&gt; email. The contents are faithfully converted to an HTML email message body that is fully responsive, so it’ll look great on both larger displays and on mobile devices. We went to great lengths to test and ensure that received emails display without problems on dozens of email clients.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-20-blastula-0-3_files/device_client_testing.png&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;If you thought that emailing &lt;strong&gt;R Markdown&lt;/strong&gt; reports from &lt;strong&gt;RStudio Connect&lt;/strong&gt; was a bit more difficult than should be, you’ll like this next part. There is now an easier-to-use methodology for associating an email to a published &lt;strong&gt;R Markdown&lt;/strong&gt; report. The function &lt;code&gt;prepare_rsc_example_files()&lt;/code&gt; is included to generate a set of example files relevant to &lt;strong&gt;R Markdown&lt;/strong&gt; emailing in &lt;strong&gt;RStudio Connect&lt;/strong&gt;. It provides a working example of a main .Rmd document, an email .Rmd document, and a CSV file that can be included as an attachment (any files generated from the main .Rmd document can also be attached). Documentation that explains how these documents interact, which &lt;strong&gt;blastula&lt;/strong&gt; functions are used, and how to publish to RSC, is available in the internal documentation for the &lt;code&gt;attach_connect_email()&lt;/code&gt; function. An updated support document in the official &lt;strong&gt;RStudio Connect&lt;/strong&gt; documentation is forthcoming.&lt;/p&gt;
&lt;p&gt;I’m pretty sure that &lt;strong&gt;RStudio Connect&lt;/strong&gt; users and the recipients of these emails will love the changes implemented here. Expect further improvements to &lt;strong&gt;R Markdown&lt;/strong&gt; emailing via &lt;strong&gt;RStudio Connect&lt;/strong&gt; in future releases of &lt;strong&gt;blastula&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;improved-html-emailing-using-smtp&#34;&gt;Improved HTML Emailing Using SMTP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;RStudio Connect&lt;/strong&gt; isn’t the only way to send emails with &lt;strong&gt;blastula&lt;/strong&gt;. We can opt to send our own custom emails through an SMTP server we have access to (e.g., Gmail, Outlook, etc.). These are HTML emails that are, again, responsive to display size and have been well tested on dozens of email clients. Let’s quickly look at three things that have changed for the better with regard to email composition and SMTP sending.&lt;/p&gt;
&lt;h3 id=&#34;revised-message-composition-with-improved-security&#34;&gt;Revised message composition with improved security&lt;/h3&gt;
&lt;p&gt;Previously, text interpolation features from the &lt;strong&gt;glue&lt;/strong&gt; package were built into the &lt;code&gt;compose_email()&lt;/code&gt; function. This means we could have used the string &lt;code&gt;&#34;The date and time of sending is {Sys.time()}.&#34;&lt;/code&gt; directly as input to, say, the message footer. Having the potential for R evaluation in strings invites security risks, so, this is no longer possible. Instead, we can simply opt to use &lt;code&gt;glue::glue()&lt;/code&gt; ourselves or &lt;code&gt;paste()&lt;/code&gt;. When there is any Markdown or HTML element, the &lt;code&gt;md()&lt;/code&gt; function is required. Here is an example of a simple message that uses Markdown:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;email &amp;lt;-
  compose_email(
    body = md(
&amp;quot;
## Hello!

This is an email message that was generated by the blastula package.

Yep, we can use **Markdown** formatting but be sure to use the `md()` function.

Here is a link to a great song ([E-MAIL ME!](https://youtu.be/-FcJbEg3vX8)).

Cheers,

The blastula team
&amp;quot;),
  footer = md(
&amp;quot;
sent via the [blastula](https://rich-iannone.github.io/blastula) R package
&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can always preview the &lt;code&gt;email&lt;/code&gt; object in the RStudio Viewer while getting the composition just right. For more details on email message composition with &lt;code&gt;compose_email()&lt;/code&gt;, have a look at the &lt;a href=&#34;https://rich-iannone.github.io/blastula/articles/simple_composition.html&#34;&gt;&lt;em&gt;Simple Email Composition&lt;/em&gt; article&lt;/a&gt; on the project website.&lt;/p&gt;
&lt;h3 id=&#34;no-external-software-to-install-for-smtp-sending&#34;&gt;No external software to install for SMTP sending&lt;/h3&gt;
&lt;p&gt;In the few years that &lt;strong&gt;blastula&lt;/strong&gt; has been available, it relied on various pieces of external software for sending email. Not anymore. This release favors the creation of an RFC-2822 email body, sending through the excellent &lt;strong&gt;curl&lt;/strong&gt; package. This all means that emails can now be sent dependably with the &lt;code&gt;smtp_send()&lt;/code&gt; function on all the major platforms with no up-front installation of a third-party binary.&lt;/p&gt;
&lt;h3 id=&#34;improved-credentials-handling&#34;&gt;Improved credentials handling&lt;/h3&gt;
&lt;p&gt;The package now ships with functions for setting up and retrieving SMTP configuration and credentials information. We can set this in the system-wide key-value store with &lt;code&gt;create_smtp_creds_key()&lt;/code&gt;. With such a key added, the credentials helper &lt;code&gt;creds_key()&lt;/code&gt; can be used when sending email through &lt;code&gt;smtp_send()&lt;/code&gt;. Alternatively, a credentials file can be created using the &lt;code&gt;create_smtp_creds_file()&lt;/code&gt; function (retrieved with the &lt;code&gt;creds_file()&lt;/code&gt; credentials helper). Lastly, credentials can be fully specified at the time of sending with the &lt;code&gt;creds()&lt;/code&gt; function. Whenever a password is needed for setup, a prompt will appear for password entry and the password text will be obscured.&lt;/p&gt;
&lt;h3 id=&#34;more&#34;&gt;More!&lt;/h3&gt;
&lt;p&gt;Other quality-of-life improvements include automatic image embedding (via Base64 encoding) from the use of the &lt;code&gt;add_image()&lt;/code&gt; and &lt;code&gt;add_ggplot()&lt;/code&gt; functions when used in conjunction with &lt;code&gt;compose_email()&lt;/code&gt;. There’s the option for automatic image deployment and retrieval of the external image tag through the &lt;code&gt;add_imgur_image()&lt;/code&gt; function. Finally, there is a new set of &lt;code&gt;block_*()&lt;/code&gt; functions that help us compose emails with more complex layouts.&lt;/p&gt;
&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;I hope that you try out the new release of the &lt;strong&gt;blastula&lt;/strong&gt; package. So many useful things can be created with &lt;strong&gt;R&lt;/strong&gt; and having the means to deliver our findings through email is super satisfying both for the sender and the recipient.&lt;/p&gt;
&lt;/div&gt;
&lt;!-- Start French Section --&gt;
&lt;div id=&#34;French&#34; class=&#34;tabcontent&#34;&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-20-blastula-0-3_files/blastula-banner.svg&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;La nouvelle version du package &lt;strong&gt;blastula&lt;/strong&gt; vous permet de faire des choses sympas avec les e-mails HTML dans &lt;strong&gt;R&lt;/strong&gt; et &lt;strong&gt;RStudio Connect&lt;/strong&gt;. Installez &lt;strong&gt;blastula&lt;/strong&gt; 0.3 de CRAN avec:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;blastula&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C’est une énorme sortie et donc il y a beaucoup de nouvelles choses… Je ne pense pas qu’il y ait assez de temps pour parler de tout ici. Mais ça va, regardons deux choses: envoyer des rapports par e-mail avec &lt;strong&gt;R Markdown&lt;/strong&gt; et des e-mails HTML améliorés (via un serveur SMTP).&lt;/p&gt;
&lt;h2 id=&#34;emailing-r-markdown-rapports-avec-rstudio-connect&#34;&gt;Emailing &lt;strong&gt;R Markdown&lt;/strong&gt; Rapports avec &lt;strong&gt;RStudio Connect&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;La possibilité d’envoyer un document &lt;strong&gt;R Markdown&lt;/strong&gt; rendu par e-mail est disponible depuis longtemps (dans &lt;strong&gt;RStudio Connect&lt;/strong&gt;). Mais c’était en pièce jointe (un peu décevant). Avec le nouveau package blastula, nous pouvons désormais créer un e-mail entièrement avec &lt;strong&gt;R Markdown&lt;/strong&gt; (le contenu va directement dans l’e-mail). De plus, nous pouvons avoir un rapport «principal» pour les téléspectateurs &lt;strong&gt;RStudio Connect&lt;/strong&gt; (avec tous les détails) et une version «e-mail» du rapport qui contient uniquement les éléments nécessaires aux fins de l’e-mail. Ah… beaucoup mieux!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-20-blastula-0-3_files/old_versus_new_rsc.png&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Les éléments statiques tels que &lt;strong&gt;ggplot&lt;/strong&gt;s et les images peuvent faire partie de l’e-mail &lt;strong&gt;R Markdown&lt;/strong&gt;. Le contenu est converti en un corps de message électronique HTML qui a fière allure sur les grands écrans et sur les téléphones cellulaires. Nous avons fait de grands efforts pour tester tout cela. Cela impliquait de consulter les e-mails de nombreux clients de messagerie.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-20-blastula-0-3_files/device_client_testing.png&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;L’envoi de rapports &lt;strong&gt;R Markdown&lt;/strong&gt; par &lt;strong&gt;RStudio Connect&lt;/strong&gt; a été un peu difficile. Il est désormais plus facile d’associer un e-mail à un rapport &lt;strong&gt;R Markdown&lt;/strong&gt; publié. La fonction &lt;code&gt;prepare_rsc_example_files()&lt;/code&gt; peut être utilisée pour générer un ensemble d’exemples de fichiers. Ces fichiers montrent comment effectuer des e-mails &lt;strong&gt;R Markdown&lt;/strong&gt; dans &lt;strong&gt;RStudio Connect&lt;/strong&gt;. Les fichiers incluent un document .Rmd principal, un document .Rmd de courrier électronique et un fichier CSV qui peut être inclus en tant que pièce jointe. Pourquoi le CSV? Parce que tous les fichiers générés à partir du document principal .Rmd peuvent également être joints! La documentation qui explique comment ces documents interagissent, quelles fonctions &lt;strong&gt;blastula&lt;/strong&gt; sont utilisées et comment publier sur RSC, est disponible dans la documentation interne de la fonction &lt;code&gt;attach_connect_email()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ouais. Je suis certain que les utilisateurs de &lt;strong&gt;RStudio Connect&lt;/strong&gt; et les destinataires de ces e-mails adoreront les changements mis en œuvre ici. Nous apporterons plus de modifications aux e-mails &lt;strong&gt;R Markdown&lt;/strong&gt; via &lt;strong&gt;RStudio Connect&lt;/strong&gt; dans les prochaines versions de &lt;strong&gt;blastula&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;emailing-html-amélioré-à-laide-de-smtp&#34;&gt;Emailing HTML amélioré à l’aide de SMTP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;RStudio Connect&lt;/strong&gt; n’est pas le seul moyen d’envoyer des e-mails avec &lt;strong&gt;blastula&lt;/strong&gt;. Nous pouvons envoyer des e-mails via un serveur SMTP auquel nous avons accès (par exemple, Gmail, Outlook, etc.). Voyons rapidement trois choses qui se sont améliorées en ce qui concerne la composition des e-mails et l’envoi SMTP.&lt;/p&gt;
&lt;h3 id=&#34;composition-des-messages-révisée-avec-plus-de-sécurité&#34;&gt;Composition des messages révisée avec plus de sécurité&lt;/h3&gt;
&lt;p&gt;Auparavant, les fonctions d’interpolation de texte du package &lt;strong&gt;glue&lt;/strong&gt; étaient intégrées à la fonction &lt;code&gt;compose_email()&lt;/code&gt;. Cela signifie que nous aurions pu utiliser la déclaration &lt;code&gt;&#34;The date and time of sending is {Sys.time()}.&#34;&lt;/code&gt; Directement comme entrée dans, disons, le pied de page du message. Le fait d’avoir le potentiel d’évaluation R dans les chaînes entraîne des risques de sécurité, ce n’est donc plus possible. Au lieu de cela, nous pouvons simplement choisir d’utiliser &lt;code&gt;glue::glue()&lt;/code&gt; nous-mêmes ou &lt;code&gt;paste()&lt;/code&gt;. Lorsqu’il y a un élément Markdown ou HTML, la fonction &lt;code&gt;md()&lt;/code&gt; est requise. Voici un exemple de message simple qui utilise Markdown (c’est en anglais):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;email &amp;lt;-
  compose_email(
    body = md(
&amp;quot;
## Hello!

This is an email message that was generated by the blastula package.

Yep, we can use **Markdown** formatting but be sure to use the `md()` function.

Here is a link to a great song ([E-MAIL ME!](https://youtu.be/-FcJbEg3vX8)).

Cheers,

The blastula team
&amp;quot;),
  footer = md(
&amp;quot;
sent via the [blastula](https://rich-iannone.github.io/blastula) R package
&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nous pouvons toujours prévisualiser l’objet &lt;code&gt;email&lt;/code&gt; dans la RStudio Viewer tout en obtenant la composition parfaite. Pour plus de détails sur la composition des e-mails avec &lt;code&gt;compose_email()&lt;/code&gt;, consultez l’article &lt;a href=&#34;https://rich-iannone.github.io/blastula/articles/simple_composition.html&#34;&gt;&lt;em&gt;Simple Email Composition&lt;/em&gt;&lt;/a&gt; sur le site web du projet.&lt;/p&gt;
&lt;h3 id=&#34;aucun-logiciel-externe-nest-nécessaire-pour-envoyer-des-e-mails-avec-smtp&#34;&gt;Aucun logiciel externe n’est nécessaire pour envoyer des e-mails avec SMTP&lt;/h3&gt;
&lt;p&gt;Au cours des quelques années où &lt;strong&gt;blastula&lt;/strong&gt; a été disponible, il s’est appuyé sur divers logiciels externes pour envoyer des e-mails. Ce n’est plus vrai. Nous créons maintenant un corps d’e-mail RFC-2822 et envoyons des e-mails avec une fonction du package &lt;strong&gt;curl&lt;/strong&gt;. Désormais, les e-mails peuvent désormais être envoyés de manière fiable avec la fonction &lt;code&gt;smtp_send()&lt;/code&gt; sur toutes les principales plates-formes informatiques sans aucune dépendance difficile à installer.&lt;/p&gt;
&lt;h3 id=&#34;amélioration-de-la-gestion-des-informations-didentification&#34;&gt;Amélioration de la gestion des informations d’identification&lt;/h3&gt;
&lt;p&gt;Le package possède désormais des fonctions de configuration et de récupération des informations de configuration et d’informations d’identification SMTP. Nous pouvons configurer cela avec &lt;code&gt;create_smtp_creds_key()&lt;/code&gt;. Avec une telle clé ajoutée, l’aide aux informations d’identification &lt;code&gt;creds_key()&lt;/code&gt; peut être utilisée lors de l’envoi d’e-mails via &lt;code&gt;smtp_send()&lt;/code&gt;. Alternativement, un fichier d’informations d’identification peut être créé en utilisant la fonction &lt;code&gt;create_smtp_creds_file()&lt;/code&gt; (récupérée avec &lt;code&gt;creds_file()&lt;/code&gt;). Enfin, les informations d’identification peuvent être entièrement spécifiées au moment de l’envoi avec la fonction &lt;code&gt;creds()&lt;/code&gt;. Chaque fois qu’un mot de passe est nécessaire, une invite apparaîtra pour la saisie du mot de passe (le texte du mot de passe sera masqué).&lt;/p&gt;
&lt;h3 id=&#34;il-y-a-encore-plus&#34;&gt;Il y a encore plus!&lt;/h3&gt;
&lt;p&gt;D’autres changements incluent l’intégration automatique d’images (via l’encodage Base64) à partir de l’utilisation des fonctions &lt;code&gt;add_image()&lt;/code&gt; et &lt;code&gt;add_ggplot()&lt;/code&gt; lorsqu’elles sont utilisées avec &lt;code&gt;compose_email()&lt;/code&gt;. La fonction &lt;code&gt;add_imgur_image()&lt;/code&gt; facilite l’utilisation d’images externes dans les e-mails. Enfin, il existe un nouvel ensemble de fonctions &lt;code&gt;block_*()&lt;/code&gt; qui nous aident à composer des e-mails avec des mises en page plus complexes.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;J’espère que vous essayez la nouvelle version du package &lt;strong&gt;blastula&lt;/strong&gt;. Nous pouvons créer des choses utiles avec &lt;strong&gt;R&lt;/strong&gt; et avoir les moyens de livrer nos résultats par e-mail est super cool pour l’expéditeur et le destinataire.&lt;/p&gt;
&lt;/div&gt;
&lt;!-- Start German Section --&gt;
&lt;div id=&#34;German&#34; class=&#34;tabcontent&#34;&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-20-blastula-0-3_files/blastula-banner.svg&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Mit der neuen Version des &lt;strong&gt;blastula&lt;/strong&gt;-Pakets können Sie in &lt;strong&gt;R&lt;/strong&gt; und &lt;strong&gt;RStudio Connect&lt;/strong&gt; coole Dinge mit HTML-E-Mails tun. Installieren Sie CRAN &lt;strong&gt;blastula&lt;/strong&gt; 0.3 mit:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;blastula&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dies ist ein ziemlich umfangreiches Software-Upgrade! Es gibt so viele neue und verbesserte Funktionen, dass wir sie hier nicht alle durcharbeiten können. Schauen wir uns zwei neue Themen an: &lt;strong&gt;R Markdown&lt;/strong&gt; Bericht-E-Mail und verbessertes HTML-E-Mail mit SMTP.&lt;/p&gt;
&lt;h2 id=&#34;r-markdown-e-mail-berichte-mit-rstudio-connect&#34;&gt;&lt;strong&gt;R Markdown&lt;/strong&gt; E-Mail-Berichte mit &lt;strong&gt;RStudio Connect&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Die Möglichkeit, ein per E-Mail gesendetes &lt;strong&gt;R Markdown&lt;/strong&gt;-Dokument zu senden, ist seit langem verfügbar (in &lt;strong&gt;RStudio Connect&lt;/strong&gt;). Aber es war anhaftend (etwas enttäuschend). Mit dem neuen Blastula-Paket können wir jetzt eine E-Mail komplett mit &lt;strong&gt;R Markdown&lt;/strong&gt; erstellen (der Inhalt geht direkt in die E-Mail). Außerdem können wir einen “Haupt”-Report für die Zuschauer &lt;strong&gt;RStudio Connect&lt;/strong&gt; (mit allen Details) und eine “E-Mail”-Version des Berichts haben, die nur die für die Zwecke der E-Mail erforderlichen Elemente enthält. Viel besser!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-20-blastula-0-3_files/old_versus_new_rsc.png&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Statische Elemente wie &lt;strong&gt;ggplot&lt;/strong&gt;s und Bilder können Teil der &lt;strong&gt;R Markdown&lt;/strong&gt;-E-Mail sein. Der Inhalt wird in einen HTML-Nachrichtentext konvertiert, der auf große Desktop-Displays und Handys großartig aussieht. Wir haben große Anstrengungen unternommen, um all dies zu testen. Dies beinhaltete das Betrachten der E-Mails vieler E-Mail-Clients.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-20-blastula-0-3_files/device_client_testing.png&#34; style=&#34;width:100.0%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Es war ein bisschen schwierig, &lt;strong&gt;R Markdown&lt;/strong&gt; von &lt;strong&gt;RStudio Connect&lt;/strong&gt; zu melden. Es ist jetzt einfacher, eine E-Mail mit einem veröffentlichten &lt;strong&gt;R Markdown&lt;/strong&gt;-Report zu verknüpfen. Die Funktion &lt;code&gt;prepare_rsc_example_files()&lt;/code&gt; kann verwendet werden, um einen Satz von Beispieldateien zu generieren. Diese Dateien zeigen, wie &lt;strong&gt;R Markdown&lt;/strong&gt;-E-Mails in &lt;strong&gt;RStudio Connect&lt;/strong&gt; erstellt werden. Die Dateien enthalten ein Haupt-RMD-Dokument, ein RMD-E-Mail-Dokument und eine CSV-Datei, die als Anhang beigefügt werden kann. Warum die CSV? Denn alle Dateien, die aus dem Hauptdokument .Rmd generiert wurden, können auch angehängt werden! Die Dokumentation, die erklärt, wie diese Dokumente interagieren, welche &lt;strong&gt;blastula&lt;/strong&gt;-Funktionen verwendet werden und wie sie in RSC veröffentlicht werden, finden Sie in der internen Dokumentation der Funktion &lt;code&gt;attach_connect_email()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ja. Ich bin sicher, dass &lt;strong&gt;RStudio Connect&lt;/strong&gt;-Nutzer und -Empfänger dieser E-Mails die hier vorgenommenen Änderungen lieben werden. In zukünftigen Versionen von &lt;strong&gt;blastula&lt;/strong&gt; werden wir weitere Änderungen an &lt;strong&gt;R Markdown&lt;/strong&gt;-E-Mails über &lt;strong&gt;RStudio Connect&lt;/strong&gt; vornehmen.&lt;/p&gt;
&lt;h2 id=&#34;erweitertes-html-e-mailing-über-smtp&#34;&gt;Erweitertes HTML-E-Mailing über SMTP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;RStudio Connect&lt;/strong&gt; ist nicht die einzige Möglichkeit, E-Mails mit &lt;strong&gt;blastula&lt;/strong&gt; zu versenden. Wir können E-Mails über einen SMTP-Server senden, auf den wir Zugriff haben (z. B. Google Mail, Outlook usw.). Schauen wir uns kurz drei Dinge an, die sich in Bezug auf die E-Mail-Zusammensetzung und den SMTP-Versand verbessert haben.&lt;/p&gt;
&lt;h3 id=&#34;überarbeitete-nachrichtenkomposition-mit-mehr-sicherheit&#34;&gt;Überarbeitete Nachrichtenkomposition mit mehr Sicherheit&lt;/h3&gt;
&lt;p&gt;Zuvor waren die Textinterpolationsfunktionen des &lt;strong&gt;glue&lt;/strong&gt;-Pakets in die Funktion &lt;code&gt;compose_email()&lt;/code&gt; integriert. Dies bedeutet, dass wir die Anweisung &lt;code&gt;&#34;The date and time of sending is {Sys.time()}.&#34;&lt;/code&gt; Direkt als Eintrag beispielsweise in der Fußzeile der Nachricht verwendet haben könnten. Das Potential zur Bewertung &lt;strong&gt;R&lt;/strong&gt; in den Ketten zu haben, führt zu Sicherheitsrisiken, so dass dies nicht mehr möglich ist. Stattdessen können wir uns einfach dafür entscheiden, &lt;code&gt;glue::glue()&lt;/code&gt; oder &lt;code&gt;paste()&lt;/code&gt; zu verwenden. Wenn ein Markdown- oder HTML-Element vorhanden ist, ist die Funktion &lt;code&gt;md()&lt;/code&gt; erforderlich. Hier ist ein Beispiel für eine einfache Nachricht, die Markdown verwendet:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;email &amp;lt;-
  compose_email(
    body = md(
&amp;quot;
## Hello!

This is an email message that was generated by the blastula package.

Yep, we can use **Markdown** formatting but be sure to use the `md()` function.

Here is a link to a great song ([E-MAIL ME!](https://youtu.be/-FcJbEg3vX8)).

Cheers,

The blastula team
&amp;quot;),
  footer = md(
&amp;quot;
sent via the [blastula](https://rich-iannone.github.io/blastula) R package
&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wir können weiterhin eine Vorschau des E-Mail-Objekts im &lt;strong&gt;RStudio Viewer&lt;/strong&gt; anzeigen, um die perfekte Komposition zu erhalten. Weitere Informationen zum Verfassen von E-Mails mit &lt;code&gt;compose_email()&lt;/code&gt; finden Sie im Artikel &lt;a href=&#34;https://rich-iannone.github.io/blastula/articles/simple_composition.html&#34;&gt;&lt;em&gt;Simple Email Composition&lt;/em&gt;&lt;/a&gt; auf der Projektwebsite.&lt;/p&gt;
&lt;h3 id=&#34;zum-versenden-von-e-mails-mit-smtp-ist-keine-externe-software-erforderlich&#34;&gt;Zum Versenden von E-Mails mit SMTP ist keine externe Software erforderlich&lt;/h3&gt;
&lt;p&gt;In den wenigen Jahren, in denen &lt;strong&gt;blastula&lt;/strong&gt; verfügbar war, stützte er sich zum Versenden von E-Mails auf verschiedene externe Software. Das stimmt nicht mehr. Wir erstellen jetzt einen RFC-2822-E-Mail-Body und senden E-Mails mit einer &lt;strong&gt;curl&lt;/strong&gt;-Paketfunktion. Jetzt können E-Mails mit der Funktion &lt;code&gt;smtp_send()&lt;/code&gt; zuverlässig auf allen wichtigen Computerplattformen ohne schwer zu installierende Abhängigkeiten gesendet werden.&lt;/p&gt;
&lt;h3 id=&#34;verbesserte-berechtigungsnachweisverwaltung&#34;&gt;Verbesserte Berechtigungsnachweisverwaltung&lt;/h3&gt;
&lt;p&gt;Das Paket verfügt jetzt über Funktionen zum Konfigurieren und Abrufen von Konfigurationsinformationen und SMTP-Anmeldeinformationen. Wir können dies mit &lt;code&gt;create_smtp_creds_key()&lt;/code&gt; konfigurieren. Mit einem solchen hinzugefügten Schlüssel kann die &lt;code&gt;creds_key()&lt;/code&gt;-Hilfe zum Versenden von E-Mails über &lt;code&gt;smtp_send()&lt;/code&gt; verwendet werden. Alternativ kann eine Berechtigungsnachweisdatei mit der Funktion &lt;code&gt;create_smtp_creds_file()&lt;/code&gt; erstellt werden (abgerufen mit &lt;code&gt;creds_file()&lt;/code&gt;). Schließlich können die Anmeldeinformationen zum Zeitpunkt des Sendens mit der Funktion &lt;code&gt;creds()&lt;/code&gt; vollständig angegeben werden. Immer wenn ein Passwort erforderlich ist, erscheint eine Aufforderung zur Eingabe des Passworts (der Passworttext wird ausgeblendet).&lt;/p&gt;
&lt;h3 id=&#34;es-gibt-noch-mehr&#34;&gt;Es gibt noch mehr!&lt;/h3&gt;
&lt;p&gt;Andere Änderungen umfassen die automatische Bildintegration (über Base64-Codierung) durch die Verwendung der Funktionen &lt;code&gt;add_image()&lt;/code&gt; und &lt;code&gt;add_ggplot()&lt;/code&gt;, wenn sie mit &lt;code&gt;compose_email()&lt;/code&gt; verwendet werden. Die Funktion &lt;code&gt;add_imgur_image()&lt;/code&gt; erleichtert die Verwendung externer Bilder in E-Mails. Schließlich gibt es eine neue Reihe von &lt;code&gt;block_*()&lt;/code&gt;-Funktionen, mit denen wir E-Mails mit komplexeren Layouts erstellen können.&lt;/p&gt;
&lt;h2 id=&#34;die-zukunft-ist-da&#34;&gt;Die Zukunft ist da&lt;/h2&gt;
&lt;p&gt;Ich hoffe aufrichtig, dass Sie die neue Version des &lt;strong&gt;blastula&lt;/strong&gt;-Pakets testen. Mit &lt;strong&gt;R&lt;/strong&gt; können wir so viele nützliche Dinge erschaffen. Die Möglichkeit, unsere Ergebnisse per E-Mail zu übermitteln, ist für den Absender und den Empfänger eine absolute Freude.&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
function openLang(evt, cityName) {
var i, tabcontent, tablinks;
tabcontent = document.getElementsByClassName(&#34;tabcontent&#34;);
for (i = 0; i &lt; tabcontent.length; i++) {
tabcontent[i].style.display = &#34;none&#34;;
}
tablinks = document.getElementsByClassName(&#34;tablinks&#34;);
for (i = 0; i &lt; tablinks.length; i++) {
tablinks[i].className = tablinks[i].className.replace(&#34; active&#34;, &#34;&#34;);
}
document.getElementById(cityName).style.display = &#34;block&#34;;
evt.currentTarget.className += &#34; active&#34;;
}

// Get the element with id=&#34;defaultOpen&#34; and click on it
document.getElementById(&#34;defaultOpen&#34;).click();
&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>
